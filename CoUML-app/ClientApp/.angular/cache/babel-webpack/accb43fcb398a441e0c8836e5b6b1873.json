{"ast":null,"code":"/**\n * Implementation of the data synchronisation protocol that brings a local and a remote document\n * into the same state. This is typically used when two nodes have been disconnected for some time,\n * and need to exchange any changes that happened while they were disconnected. The two nodes that\n * are syncing could be client and server, or server and client, or two peers with symmetric roles.\n *\n * The protocol is based on this paper: Martin Kleppmann and Heidi Howard. Byzantine Eventual\n * Consistency and the Fundamental Limits of Peer-to-Peer Databases. https://arxiv.org/abs/2012.00472\n *\n * The protocol assumes that every time a node successfully syncs with another node, it remembers\n * the current heads (as returned by `Backend.getHeads()`) after the last sync with that node. The\n * next time we try to sync with the same node, we start from the assumption that the other node's\n * document version is no older than the outcome of the last sync, so we only need to exchange any\n * changes that are more recent than the last sync. This assumption may not be true if the other\n * node did not correctly persist its state (perhaps it crashed before writing the result of the\n * last sync to disk), and we fall back to sending the entire document in this case.\n */\nconst Backend = require('./backend');\n\nconst {\n  hexStringToBytes,\n  bytesToHexString,\n  Encoder,\n  Decoder\n} = require('./encoding');\n\nconst {\n  decodeChangeMeta\n} = require('./columnar');\n\nconst {\n  copyObject\n} = require('../src/common');\n\nconst HASH_SIZE = 32; // 256 bits = 32 bytes\n\nconst MESSAGE_TYPE_SYNC = 0x42; // first byte of a sync message, for identification\n\nconst PEER_STATE_TYPE = 0x43; // first byte of an encoded peer state, for identification\n// These constants correspond to a 1% false positive rate. The values can be changed without\n// breaking compatibility of the network protocol, since the parameters used for a particular\n// Bloom filter are encoded in the wire format.\n\nconst BITS_PER_ENTRY = 10,\n      NUM_PROBES = 7;\n/**\n * A Bloom filter implementation that can be serialised to a byte array for transmission\n * over a network. The entries that are added are assumed to already be SHA-256 hashes,\n * so this implementation does not perform its own hashing.\n */\n\nclass BloomFilter {\n  constructor(arg) {\n    if (Array.isArray(arg)) {\n      // arg is an array of SHA256 hashes in hexadecimal encoding\n      this.numEntries = arg.length;\n      this.numBitsPerEntry = BITS_PER_ENTRY;\n      this.numProbes = NUM_PROBES;\n      this.bits = new Uint8Array(Math.ceil(this.numEntries * this.numBitsPerEntry / 8));\n\n      for (let hash of arg) this.addHash(hash);\n    } else if (arg instanceof Uint8Array) {\n      if (arg.byteLength === 0) {\n        this.numEntries = 0;\n        this.numBitsPerEntry = 0;\n        this.numProbes = 0;\n        this.bits = arg;\n      } else {\n        const decoder = new Decoder(arg);\n        this.numEntries = decoder.readUint32();\n        this.numBitsPerEntry = decoder.readUint32();\n        this.numProbes = decoder.readUint32();\n        this.bits = decoder.readRawBytes(Math.ceil(this.numEntries * this.numBitsPerEntry / 8));\n      }\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  }\n  /**\n   * Returns the Bloom filter state, encoded as a byte array.\n   */\n\n\n  get bytes() {\n    if (this.numEntries === 0) return new Uint8Array(0);\n    const encoder = new Encoder();\n    encoder.appendUint32(this.numEntries);\n    encoder.appendUint32(this.numBitsPerEntry);\n    encoder.appendUint32(this.numProbes);\n    encoder.appendRawBytes(this.bits);\n    return encoder.buffer;\n  }\n  /**\n   * Given a SHA-256 hash (as hex string), returns an array of probe indexes indicating which bits\n   * in the Bloom filter need to be tested or set for this particular entry. We do this by\n   * interpreting the first 12 bytes of the hash as three little-endian 32-bit unsigned integers,\n   * and then using triple hashing to compute the probe indexes. The algorithm comes from:\n   *\n   * Peter C. Dillinger and Panagiotis Manolios. Bloom Filters in Probabilistic Verification.\n   * 5th International Conference on Formal Methods in Computer-Aided Design (FMCAD), November 2004.\n   * http://www.ccis.northeastern.edu/home/pete/pub/bloom-filters-verification.pdf\n   */\n\n\n  getProbes(hash) {\n    const hashBytes = hexStringToBytes(hash),\n          modulo = 8 * this.bits.byteLength;\n    if (hashBytes.byteLength !== 32) throw new RangeError(`Not a 256-bit hash: ${hash}`); // on the next three lines, the right shift means interpret value as unsigned\n\n    let x = ((hashBytes[0] | hashBytes[1] << 8 | hashBytes[2] << 16 | hashBytes[3] << 24) >>> 0) % modulo;\n    let y = ((hashBytes[4] | hashBytes[5] << 8 | hashBytes[6] << 16 | hashBytes[7] << 24) >>> 0) % modulo;\n    let z = ((hashBytes[8] | hashBytes[9] << 8 | hashBytes[10] << 16 | hashBytes[11] << 24) >>> 0) % modulo;\n    const probes = [x];\n\n    for (let i = 1; i < this.numProbes; i++) {\n      x = (x + y) % modulo;\n      y = (y + z) % modulo;\n      probes.push(x);\n    }\n\n    return probes;\n  }\n  /**\n   * Sets the Bloom filter bits corresponding to a given SHA-256 hash (given as hex string).\n   */\n\n\n  addHash(hash) {\n    for (let probe of this.getProbes(hash)) {\n      this.bits[probe >>> 3] |= 1 << (probe & 7);\n    }\n  }\n  /**\n   * Tests whether a given SHA-256 hash (given as hex string) is contained in the Bloom filter.\n   */\n\n\n  containsHash(hash) {\n    if (this.numEntries === 0) return false;\n\n    for (let probe of this.getProbes(hash)) {\n      if ((this.bits[probe >>> 3] & 1 << (probe & 7)) === 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n/**\n * Encodes a sorted array of SHA-256 hashes (as hexadecimal strings) into a byte array.\n */\n\n\nfunction encodeHashes(encoder, hashes) {\n  if (!Array.isArray(hashes)) throw new TypeError('hashes must be an array');\n  encoder.appendUint32(hashes.length);\n\n  for (let i = 0; i < hashes.length; i++) {\n    if (i > 0 && hashes[i - 1] >= hashes[i]) throw new RangeError('hashes must be sorted');\n    const bytes = hexStringToBytes(hashes[i]);\n    if (bytes.byteLength !== HASH_SIZE) throw new TypeError('heads hashes must be 256 bits');\n    encoder.appendRawBytes(bytes);\n  }\n}\n/**\n * Decodes a byte array in the format returned by encodeHashes(), and returns its content as an\n * array of hex strings.\n */\n\n\nfunction decodeHashes(decoder) {\n  let length = decoder.readUint32(),\n      hashes = [];\n\n  for (let i = 0; i < length; i++) {\n    hashes.push(bytesToHexString(decoder.readRawBytes(HASH_SIZE)));\n  }\n\n  return hashes;\n}\n/**\n * Takes a sync message of the form `{heads, need, have, changes}` and encodes it as a byte array for\n * transmission.\n */\n\n\nfunction encodeSyncMessage(message) {\n  const encoder = new Encoder();\n  encoder.appendByte(MESSAGE_TYPE_SYNC);\n  encodeHashes(encoder, message.heads);\n  encodeHashes(encoder, message.need);\n  encoder.appendUint32(message.have.length);\n\n  for (let have of message.have) {\n    encodeHashes(encoder, have.lastSync);\n    encoder.appendPrefixedBytes(have.bloom);\n  }\n\n  encoder.appendUint32(message.changes.length);\n\n  for (let change of message.changes) {\n    encoder.appendPrefixedBytes(change);\n  }\n\n  return encoder.buffer;\n}\n/**\n * Takes a binary-encoded sync message and decodes it into the form `{heads, need, have, changes}`.\n */\n\n\nfunction decodeSyncMessage(bytes) {\n  const decoder = new Decoder(bytes);\n  const messageType = decoder.readByte();\n\n  if (messageType !== MESSAGE_TYPE_SYNC) {\n    throw new RangeError(`Unexpected message type: ${messageType}`);\n  }\n\n  const heads = decodeHashes(decoder);\n  const need = decodeHashes(decoder);\n  const haveCount = decoder.readUint32();\n  let message = {\n    heads,\n    need,\n    have: [],\n    changes: []\n  };\n\n  for (let i = 0; i < haveCount; i++) {\n    const lastSync = decodeHashes(decoder);\n    const bloom = decoder.readPrefixedBytes(decoder);\n    message.have.push({\n      lastSync,\n      bloom\n    });\n  }\n\n  const changeCount = decoder.readUint32();\n\n  for (let i = 0; i < changeCount; i++) {\n    const change = decoder.readPrefixedBytes();\n    message.changes.push(change);\n  } // Ignore any trailing bytes -- they can be used for extensions by future versions of the protocol\n\n\n  return message;\n}\n/**\n * Takes a SyncState and encodes as a byte array those parts of the state that should persist across\n * an application restart or disconnect and reconnect. The ephemeral parts of the state that should\n * be cleared on reconnect are not encoded.\n */\n\n\nfunction encodeSyncState(syncState) {\n  const encoder = new Encoder();\n  encoder.appendByte(PEER_STATE_TYPE);\n  encodeHashes(encoder, syncState.sharedHeads);\n  return encoder.buffer;\n}\n/**\n * Takes a persisted peer state as encoded by `encodeSyncState` and decodes it into a SyncState\n * object. The parts of the peer state that were not encoded are initialised with default values.\n */\n\n\nfunction decodeSyncState(bytes) {\n  const decoder = new Decoder(bytes);\n  const recordType = decoder.readByte();\n\n  if (recordType !== PEER_STATE_TYPE) {\n    throw new RangeError(`Unexpected record type: ${recordType}`);\n  }\n\n  const sharedHeads = decodeHashes(decoder);\n  return Object.assign(initSyncState(), {\n    sharedHeads\n  });\n}\n/**\n * Constructs a Bloom filter containing all changes that are not one of the hashes in\n * `lastSync` or its transitive dependencies. In other words, the filter contains those\n * changes that have been applied since the version identified by `lastSync`. Returns\n * an object of the form `{lastSync, bloom}` as required for the `have` field of a sync\n * message.\n */\n\n\nfunction makeBloomFilter(backend, lastSync) {\n  const newChanges = Backend.getChanges(backend, lastSync);\n  const hashes = newChanges.map(change => decodeChangeMeta(change, true).hash);\n  return {\n    lastSync,\n    bloom: new BloomFilter(hashes).bytes\n  };\n}\n/**\n * Call this function when a sync message is received from another node. The `message` argument\n * needs to already have been decoded using `decodeSyncMessage()`. This function determines the\n * changes that we need to send to the other node in response. Returns an array of changes (as\n * byte arrays).\n */\n\n\nfunction getChangesToSend(backend, have, need) {\n  if (have.length === 0) {\n    return need.map(hash => Backend.getChangeByHash(backend, hash)).filter(change => change !== undefined);\n  }\n\n  let lastSyncHashes = {},\n      bloomFilters = [];\n\n  for (let h of have) {\n    for (let hash of h.lastSync) lastSyncHashes[hash] = true;\n\n    bloomFilters.push(new BloomFilter(h.bloom));\n  } // Get all changes that were added since the last sync\n\n\n  const changes = Backend.getChanges(backend, Object.keys(lastSyncHashes)).map(change => decodeChangeMeta(change, true));\n  let changeHashes = {},\n      dependents = {},\n      hashesToSend = {};\n\n  for (let change of changes) {\n    changeHashes[change.hash] = true; // For each change, make a list of changes that depend on it\n\n    for (let dep of change.deps) {\n      if (!dependents[dep]) dependents[dep] = [];\n      dependents[dep].push(change.hash);\n    } // Exclude any change hashes contained in one or more Bloom filters\n\n\n    if (bloomFilters.every(bloom => !bloom.containsHash(change.hash))) {\n      hashesToSend[change.hash] = true;\n    }\n  } // Include any changes that depend on a Bloom-negative change\n\n\n  let stack = Object.keys(hashesToSend);\n\n  while (stack.length > 0) {\n    const hash = stack.pop();\n\n    if (dependents[hash]) {\n      for (let dep of dependents[hash]) {\n        if (!hashesToSend[dep]) {\n          hashesToSend[dep] = true;\n          stack.push(dep);\n        }\n      }\n    }\n  } // Include any explicitly requested changes\n\n\n  let changesToSend = [];\n\n  for (let hash of need) {\n    hashesToSend[hash] = true;\n\n    if (!changeHashes[hash]) {\n      // Change is not among those returned by getMissingChanges()?\n      const change = Backend.getChangeByHash(backend, hash);\n      if (change) changesToSend.push(change);\n    }\n  } // Return changes in the order they were returned by getMissingChanges()\n\n\n  for (let change of changes) {\n    if (hashesToSend[change.hash]) changesToSend.push(change.change);\n  }\n\n  return changesToSend;\n}\n\nfunction initSyncState() {\n  return {\n    sharedHeads: [],\n    lastSentHeads: [],\n    theirHeads: null,\n    theirNeed: null,\n    theirHave: null,\n    sentHashes: {}\n  };\n}\n\nfunction compareArrays(a, b) {\n  return a.length === b.length && a.every((v, i) => v === b[i]);\n}\n/**\n * Given a backend and what we believe to be the state of our peer, generate a message which tells\n * them about we have and includes any changes we believe they need\n */\n\n\nfunction generateSyncMessage(backend, syncState) {\n  if (!backend) {\n    throw new Error(\"generateSyncMessage called with no Automerge document\");\n  }\n\n  if (!syncState) {\n    throw new Error(\"generateSyncMessage requires a syncState, which can be created with initSyncState()\");\n  }\n\n  let {\n    sharedHeads,\n    lastSentHeads,\n    theirHeads,\n    theirNeed,\n    theirHave,\n    sentHashes\n  } = syncState;\n  const ourHeads = Backend.getHeads(backend); // Hashes to explicitly request from the remote peer: any missing dependencies of unapplied\n  // changes, and any of the remote peer's heads that we don't know about\n\n  const ourNeed = Backend.getMissingDeps(backend, theirHeads || []); // There are two reasons why ourNeed may be nonempty: 1. we might be missing dependencies due to\n  // Bloom filter false positives; 2. we might be missing heads that the other peer mentioned\n  // because they (intentionally) only sent us a subset of changes. In case 1, we leave the `have`\n  // field of the message empty because we just want to fill in the missing dependencies for now.\n  // In case 2, or if ourNeed is empty, we send a Bloom filter to request any unsent changes.\n\n  let ourHave = [];\n\n  if (!theirHeads || ourNeed.every(hash => theirHeads.includes(hash))) {\n    ourHave = [makeBloomFilter(backend, sharedHeads)];\n  } // Fall back to a full re-sync if the sender's last sync state includes hashes\n  // that we don't know. This could happen if we crashed after the last sync and\n  // failed to persist changes that the other node already sent us.\n\n\n  if (theirHave && theirHave.length > 0) {\n    const lastSync = theirHave[0].lastSync;\n\n    if (!lastSync.every(hash => Backend.getChangeByHash(backend, hash))) {\n      // we need to queue them to send us a fresh sync message, the one they sent is uninteligible so we don't know what they need\n      const resetMsg = {\n        heads: ourHeads,\n        need: [],\n        have: [{\n          lastSync: [],\n          bloom: new Uint8Array(0)\n        }],\n        changes: []\n      };\n      return [syncState, encodeSyncMessage(resetMsg)];\n    }\n  } // XXX: we should limit ourselves to only sending a subset of all the messages, probably limited by a total message size\n  //      these changes should ideally be RLE encoded but we haven't implemented that yet.\n\n\n  let changesToSend = Array.isArray(theirHave) && Array.isArray(theirNeed) ? getChangesToSend(backend, theirHave, theirNeed) : []; // If the heads are equal, we're in sync and don't need to do anything further\n\n  const headsUnchanged = Array.isArray(lastSentHeads) && compareArrays(ourHeads, lastSentHeads);\n  const headsEqual = Array.isArray(theirHeads) && compareArrays(ourHeads, theirHeads);\n\n  if (headsUnchanged && headsEqual && changesToSend.length === 0) {\n    // no need to send a sync message if we know we're synced!\n    return [syncState, null];\n  } // TODO: this recomputes the SHA-256 hash of each change; we should restructure this to avoid the\n  // unnecessary recomputation\n\n\n  changesToSend = changesToSend.filter(change => !sentHashes[decodeChangeMeta(change, true).hash]); // Regular response to a sync message: send any changes that the other node\n  // doesn't have. We leave the \"have\" field empty because the previous message\n  // generated by `syncStart` already indicated what changes we have.\n\n  const syncMessage = {\n    heads: ourHeads,\n    have: ourHave,\n    need: ourNeed,\n    changes: changesToSend\n  };\n\n  if (changesToSend.length > 0) {\n    sentHashes = copyObject(sentHashes);\n\n    for (const change of changesToSend) {\n      sentHashes[decodeChangeMeta(change, true).hash] = true;\n    }\n  }\n\n  syncState = Object.assign({}, syncState, {\n    lastSentHeads: ourHeads,\n    sentHashes\n  });\n  return [syncState, encodeSyncMessage(syncMessage)];\n}\n/**\n * Computes the heads that we share with a peer after we have just received some changes from that\n * peer and applied them. This may not be sufficient to bring our heads in sync with the other\n * peer's heads, since they may have only sent us a subset of their outstanding changes.\n *\n * `myOldHeads` are the local heads before the most recent changes were applied, `myNewHeads` are\n * the local heads after those changes were applied, and `ourOldSharedHeads` is the previous set of\n * shared heads. Applying the changes will have replaced some heads with others, but some heads may\n * have remained unchanged (because they are for branches on which no changes have been added). Any\n * such unchanged heads remain in the sharedHeads. Any sharedHeads that were replaced by applying\n * changes are also replaced as sharedHeads. This is safe because if we received some changes from\n * another peer, that means that peer had those changes, and therefore we now both know about them.\n */\n\n\nfunction advanceHeads(myOldHeads, myNewHeads, ourOldSharedHeads) {\n  const newHeads = myNewHeads.filter(head => !myOldHeads.includes(head));\n  const commonHeads = ourOldSharedHeads.filter(head => myNewHeads.includes(head));\n  const advancedHeads = [...new Set([...newHeads, ...commonHeads])].sort();\n  return advancedHeads;\n}\n/**\n * Given a backend, a message message and the state of our peer, apply any changes, update what\n * we believe about the peer, and (if there were applied changes) produce a patch for the frontend\n */\n\n\nfunction receiveSyncMessage(backend, oldSyncState, binaryMessage) {\n  if (!backend) {\n    throw new Error(\"generateSyncMessage called with no Automerge document\");\n  }\n\n  if (!oldSyncState) {\n    throw new Error(\"generateSyncMessage requires a syncState, which can be created with initSyncState()\");\n  }\n\n  let {\n    sharedHeads,\n    lastSentHeads,\n    sentHashes\n  } = oldSyncState,\n      patch = null;\n  const message = decodeSyncMessage(binaryMessage);\n  const beforeHeads = Backend.getHeads(backend); // If we received changes, we try to apply them to the document. There may still be missing\n  // dependencies due to Bloom filter false positives, in which case the backend will enqueue the\n  // changes without applying them. The set of changes may also be incomplete if the sender decided\n  // to break a large set of changes into chunks.\n\n  if (message.changes.length > 0) {\n    [backend, patch] = Backend.applyChanges(backend, message.changes);\n    sharedHeads = advanceHeads(beforeHeads, Backend.getHeads(backend), sharedHeads);\n  } // If heads are equal, indicate we don't need to send a response message\n\n\n  if (message.changes.length === 0 && compareArrays(message.heads, beforeHeads)) {\n    lastSentHeads = message.heads;\n  } // If all of the remote heads are known to us, that means either our heads are equal, or we are\n  // ahead of the remote peer. In this case, take the remote heads to be our shared heads.\n\n\n  const knownHeads = message.heads.filter(head => Backend.getChangeByHash(backend, head));\n\n  if (knownHeads.length === message.heads.length) {\n    sharedHeads = message.heads; // If the remote peer has lost all its data, reset our state to perform a full resync\n\n    if (message.heads.length === 0) {\n      lastSentHeads = [];\n      sentHashes = [];\n    }\n  } else {\n    // If some remote heads are unknown to us, we add all the remote heads we know to\n    // sharedHeads, but don't remove anything from sharedHeads. This might cause sharedHeads to\n    // contain some redundant hashes (where one hash is actually a transitive dependency of\n    // another), but this will be cleared up as soon as we know all the remote heads.\n    sharedHeads = [...new Set(knownHeads.concat(sharedHeads))].sort();\n  }\n\n  const syncState = {\n    sharedHeads,\n    // what we have in common to generate an efficient bloom filter\n    lastSentHeads,\n    theirHave: message.have,\n    // the information we need to calculate the changes they need\n    theirHeads: message.heads,\n    theirNeed: message.need,\n    sentHashes\n  };\n  return [backend, syncState, patch];\n}\n\nmodule.exports = {\n  receiveSyncMessage,\n  generateSyncMessage,\n  encodeSyncMessage,\n  decodeSyncMessage,\n  initSyncState,\n  encodeSyncState,\n  decodeSyncState,\n  BloomFilter // BloomFilter is a private API, exported only for testing purposes\n\n};","map":null,"metadata":{},"sourceType":"script"}