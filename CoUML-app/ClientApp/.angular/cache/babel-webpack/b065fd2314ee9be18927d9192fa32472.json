{"ast":null,"code":"const {\n  OBJECT_ID,\n  CHANGE,\n  STATE\n} = require('./constants');\n\nconst {\n  createArrayOfNulls\n} = require('../src/common');\n\nconst {\n  Text\n} = require('./text');\n\nconst {\n  Table\n} = require('./table');\n\nfunction parseListIndex(key) {\n  if (typeof key === 'string' && /^[0-9]+$/.test(key)) key = parseInt(key, 10);\n\n  if (typeof key !== 'number') {\n    throw new TypeError('A list index must be a number, but you passed ' + JSON.stringify(key));\n  }\n\n  if (key < 0 || isNaN(key) || key === Infinity || key === -Infinity) {\n    throw new RangeError('A list index must be positive, but you passed ' + key);\n  }\n\n  return key;\n}\n\nfunction listMethods(context, listId, path) {\n  const methods = {\n    deleteAt(index, numDelete) {\n      context.splice(path, parseListIndex(index), numDelete || 1, []);\n      return this;\n    },\n\n    fill(value, start, end) {\n      let list = context.getObject(listId);\n\n      for (let index = parseListIndex(start || 0); index < parseListIndex(end || list.length); index++) {\n        context.setListIndex(path, index, value);\n      }\n\n      return this;\n    },\n\n    indexOf(o, start = 0) {\n      const id = o[OBJECT_ID];\n\n      if (id) {\n        const list = context.getObject(listId);\n\n        for (let index = start; index < list.length; index++) {\n          if (list[index][OBJECT_ID] === id) {\n            return index;\n          }\n        }\n\n        return -1;\n      } else {\n        return context.getObject(listId).indexOf(o, start);\n      }\n    },\n\n    insertAt(index, ...values) {\n      context.splice(path, parseListIndex(index), 0, values);\n      return this;\n    },\n\n    pop() {\n      let list = context.getObject(listId);\n      if (list.length == 0) return;\n      const last = context.getObjectField(path, listId, list.length - 1);\n      context.splice(path, list.length - 1, 1, []);\n      return last;\n    },\n\n    push(...values) {\n      let list = context.getObject(listId);\n      context.splice(path, list.length, 0, values); // need to getObject() again because the list object above may be immutable\n\n      return context.getObject(listId).length;\n    },\n\n    shift() {\n      let list = context.getObject(listId);\n      if (list.length == 0) return;\n      const first = context.getObjectField(path, listId, 0);\n      context.splice(path, 0, 1, []);\n      return first;\n    },\n\n    splice(start, deleteCount, ...values) {\n      let list = context.getObject(listId);\n      start = parseListIndex(start);\n\n      if (deleteCount === undefined || deleteCount > list.length - start) {\n        deleteCount = list.length - start;\n      }\n\n      const deleted = [];\n\n      for (let n = 0; n < deleteCount; n++) {\n        deleted.push(context.getObjectField(path, listId, start + n));\n      }\n\n      context.splice(path, start, deleteCount, values);\n      return deleted;\n    },\n\n    unshift(...values) {\n      context.splice(path, 0, 0, values);\n      return context.getObject(listId).length;\n    }\n\n  };\n\n  for (let iterator of ['entries', 'keys', 'values']) {\n    let list = context.getObject(listId);\n\n    methods[iterator] = () => list[iterator]();\n  } // Read-only methods that can delegate to the JavaScript built-in implementations\n\n\n  for (let method of ['concat', 'every', 'filter', 'find', 'findIndex', 'forEach', 'includes', 'join', 'lastIndexOf', 'map', 'reduce', 'reduceRight', 'slice', 'some', 'toLocaleString', 'toString']) {\n    methods[method] = (...args) => {\n      const list = context.getObject(listId).map((item, index) => context.getObjectField(path, listId, index));\n      return list[method](...args);\n    };\n  }\n\n  return methods;\n}\n\nconst MapHandler = {\n  get(target, key) {\n    const {\n      context,\n      objectId,\n      path\n    } = target;\n    if (key === OBJECT_ID) return objectId;\n    if (key === CHANGE) return context;\n    if (key === STATE) return {\n      actorId: context.actorId\n    };\n    return context.getObjectField(path, objectId, key);\n  },\n\n  set(target, key, value) {\n    const {\n      context,\n      path,\n      readonly\n    } = target;\n\n    if (Array.isArray(readonly) && readonly.indexOf(key) >= 0) {\n      throw new RangeError(`Object property \"${key}\" cannot be modified`);\n    }\n\n    context.setMapKey(path, key, value);\n    return true;\n  },\n\n  deleteProperty(target, key) {\n    const {\n      context,\n      path,\n      readonly\n    } = target;\n\n    if (Array.isArray(readonly) && readonly.indexOf(key) >= 0) {\n      throw new RangeError(`Object property \"${key}\" cannot be modified`);\n    }\n\n    context.deleteMapKey(path, key);\n    return true;\n  },\n\n  has(target, key) {\n    const {\n      context,\n      objectId\n    } = target;\n    return [OBJECT_ID, CHANGE].includes(key) || key in context.getObject(objectId);\n  },\n\n  getOwnPropertyDescriptor(target, key) {\n    const {\n      context,\n      objectId\n    } = target;\n    const object = context.getObject(objectId);\n\n    if (key in object) {\n      return {\n        configurable: true,\n        enumerable: true,\n        value: context.getObjectField(objectId, key)\n      };\n    }\n  },\n\n  ownKeys(target) {\n    const {\n      context,\n      objectId\n    } = target;\n    return Object.keys(context.getObject(objectId));\n  }\n\n};\nconst ListHandler = {\n  get(target, key) {\n    const [context, objectId, path] = target;\n    if (key === Symbol.iterator) return context.getObject(objectId)[Symbol.iterator];\n    if (key === OBJECT_ID) return objectId;\n    if (key === CHANGE) return context;\n    if (key === 'length') return context.getObject(objectId).length;\n\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      return context.getObjectField(path, objectId, parseListIndex(key));\n    }\n\n    return listMethods(context, objectId, path)[key];\n  },\n\n  set(target, key, value) {\n    const [context, objectId, path] = target;\n\n    if (key === 'length') {\n      if (typeof value !== 'number') {\n        throw new RangeError(\"Invalid array length\");\n      }\n\n      const length = context.getObject(objectId).length;\n\n      if (length > value) {\n        context.splice(path, value, length - value, []);\n      } else {\n        context.splice(path, length, 0, createArrayOfNulls(value - length));\n      }\n    } else {\n      context.setListIndex(path, parseListIndex(key), value);\n    }\n\n    return true;\n  },\n\n  deleteProperty(target, key) {\n    const [\n      /* objectId */\n    context,, path] = target;\n    context.splice(path, parseListIndex(key), 1, []);\n    return true;\n  },\n\n  has(target, key) {\n    const [context, objectId\n    /* path */\n    ] = target;\n\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      return parseListIndex(key) < context.getObject(objectId).length;\n    }\n\n    return ['length', OBJECT_ID, CHANGE].includes(key);\n  },\n\n  getOwnPropertyDescriptor(target, key) {\n    const [context, objectId\n    /* path */\n    ] = target;\n    const object = context.getObject(objectId);\n    if (key === 'length') return {\n      writable: true,\n      value: object.length\n    };\n    if (key === OBJECT_ID) return {\n      configurable: false,\n      enumerable: false,\n      value: objectId\n    };\n\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      const index = parseListIndex(key);\n      if (index < object.length) return {\n        configurable: true,\n        enumerable: true,\n        value: context.getObjectField(objectId, index)\n      };\n    }\n  },\n\n  ownKeys(target) {\n    const [context, objectId\n    /* path */\n    ] = target;\n    const object = context.getObject(objectId);\n    let keys = ['length'];\n\n    for (let key of Object.keys(object)) keys.push(key);\n\n    return keys;\n  }\n\n};\n\nfunction mapProxy(context, objectId, path, readonly) {\n  return new Proxy({\n    context,\n    objectId,\n    path,\n    readonly\n  }, MapHandler);\n}\n\nfunction listProxy(context, objectId, path) {\n  return new Proxy([context, objectId, path], ListHandler);\n}\n/**\n * Instantiates a proxy object for the given `objectId`.\n * This function is added as a method to the context object by rootObjectProxy().\n * When it is called, `this` is the context object.\n * `readonly` is a list of map property names that cannot be modified.\n */\n\n\nfunction instantiateProxy(path, objectId, readonly) {\n  const object = this.getObject(objectId);\n\n  if (Array.isArray(object)) {\n    return listProxy(this, objectId, path);\n  } else if (object instanceof Text || object instanceof Table) {\n    return object.getWriteable(this, path);\n  } else {\n    return mapProxy(this, objectId, path, readonly);\n  }\n}\n\nfunction rootObjectProxy(context) {\n  context.instantiateObject = instantiateProxy;\n  return mapProxy(context, '_root', []);\n}\n\nmodule.exports = {\n  rootObjectProxy\n};","map":null,"metadata":{},"sourceType":"script"}