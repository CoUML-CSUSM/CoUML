{"ast":null,"code":"const {\n  OPTIONS,\n  CACHE,\n  STATE,\n  OBJECT_ID,\n  CONFLICTS,\n  CHANGE,\n  ELEM_IDS\n} = require('./constants');\n\nconst {\n  isObject,\n  copyObject\n} = require('../src/common');\n\nconst uuid = require('../src/uuid');\n\nconst {\n  interpretPatch,\n  cloneRootObject\n} = require('./apply_patch');\n\nconst {\n  rootObjectProxy\n} = require('./proxies');\n\nconst {\n  Context\n} = require('./context');\n\nconst {\n  Text\n} = require('./text');\n\nconst {\n  Table\n} = require('./table');\n\nconst {\n  Counter\n} = require('./counter');\n\nconst {\n  Float64,\n  Int,\n  Uint\n} = require('./numbers');\n\nconst {\n  Observable\n} = require('./observable');\n/**\n * Actor IDs must consist only of hexadecimal digits so that they can be encoded\n * compactly in binary form.\n */\n\n\nfunction checkActorId(actorId) {\n  if (typeof actorId !== 'string') {\n    throw new TypeError(`Unsupported type of actorId: ${typeof actorId}`);\n  }\n\n  if (!/^[0-9a-f]+$/.test(actorId)) {\n    throw new RangeError('actorId must consist only of lowercase hex digits');\n  }\n\n  if (actorId.length % 2 !== 0) {\n    throw new RangeError('actorId must consist of an even number of digits');\n  }\n}\n/**\n * Takes a set of objects that have been updated (in `updated`) and an updated state object\n * `state`, and returns a new immutable document root object based on `doc` that reflects\n * those updates.\n */\n\n\nfunction updateRootObject(doc, updated, state) {\n  let newDoc = updated._root;\n\n  if (!newDoc) {\n    newDoc = cloneRootObject(doc[CACHE]._root);\n    updated._root = newDoc;\n  }\n\n  Object.defineProperty(newDoc, OPTIONS, {\n    value: doc[OPTIONS]\n  });\n  Object.defineProperty(newDoc, CACHE, {\n    value: updated\n  });\n  Object.defineProperty(newDoc, STATE, {\n    value: state\n  });\n\n  if (doc[OPTIONS].freeze) {\n    for (let objectId of Object.keys(updated)) {\n      if (updated[objectId] instanceof Table) {\n        updated[objectId]._freeze();\n      } else if (updated[objectId] instanceof Text) {\n        Object.freeze(updated[objectId].elems);\n        Object.freeze(updated[objectId]);\n      } else {\n        Object.freeze(updated[objectId]);\n        Object.freeze(updated[objectId][CONFLICTS]);\n      }\n    }\n  }\n\n  for (let objectId of Object.keys(doc[CACHE])) {\n    if (!updated[objectId]) {\n      updated[objectId] = doc[CACHE][objectId];\n    }\n  }\n\n  if (doc[OPTIONS].freeze) {\n    Object.freeze(updated);\n  }\n\n  return newDoc;\n}\n/**\n * Adds a new change request to the list of pending requests, and returns an\n * updated document root object.\n * The details of the change are taken from the context object `context`.\n * `options` contains properties that may affect how the change is processed; in\n * particular, the `message` property of `options` is an optional human-readable\n * string describing the change.\n */\n\n\nfunction makeChange(doc, context, options) {\n  const actor = getActorId(doc);\n\n  if (!actor) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change');\n  }\n\n  const state = copyObject(doc[STATE]);\n  state.seq += 1;\n  const change = {\n    actor,\n    seq: state.seq,\n    startOp: state.maxOp + 1,\n    deps: state.deps,\n    time: options && typeof options.time === 'number' ? options.time : Math.round(new Date().getTime() / 1000),\n    message: options && typeof options.message === 'string' ? options.message : '',\n    ops: context.ops\n  };\n\n  if (doc[OPTIONS].backend) {\n    const [backendState, patch, binaryChange] = doc[OPTIONS].backend.applyLocalChange(state.backendState, change);\n    state.backendState = backendState;\n    state.lastLocalChange = binaryChange; // NOTE: When performing a local change, the patch is effectively applied twice -- once by the\n    // context invoking interpretPatch as soon as any change is made, and the second time here\n    // (after a round-trip through the backend). This is perhaps more robust, as changes only take\n    // effect in the form processed by the backend, but the downside is a performance cost.\n    // Should we change this?\n\n    const newDoc = applyPatchToDoc(doc, patch, state, true);\n    const patchCallback = options && options.patchCallback || doc[OPTIONS].patchCallback;\n    if (patchCallback) patchCallback(patch, doc, newDoc, true, [binaryChange]);\n    return [newDoc, change];\n  } else {\n    const queuedRequest = {\n      actor,\n      seq: change.seq,\n      before: doc\n    };\n    state.requests = state.requests.concat([queuedRequest]);\n    state.maxOp = state.maxOp + countOps(change.ops);\n    state.deps = [];\n    return [updateRootObject(doc, context ? context.updated : {}, state), change];\n  }\n}\n\nfunction countOps(ops) {\n  let count = 0;\n\n  for (const op of ops) {\n    if (op.action === 'set' && op.values) {\n      count += op.values.length;\n    } else {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n/**\n * Returns the binary encoding of the last change made by the local actor.\n */\n\n\nfunction getLastLocalChange(doc) {\n  return doc[STATE] && doc[STATE].lastLocalChange ? doc[STATE].lastLocalChange : null;\n}\n/**\n * Applies the changes described in `patch` to the document with root object\n * `doc`. The state object `state` is attached to the new root object.\n * `fromBackend` should be set to `true` if the patch came from the backend,\n * and to `false` if the patch is a transient local (optimistically applied)\n * change from the frontend.\n */\n\n\nfunction applyPatchToDoc(doc, patch, state, fromBackend) {\n  const actor = getActorId(doc);\n  const updated = {};\n  interpretPatch(patch.diffs, doc, updated);\n\n  if (fromBackend) {\n    if (!patch.clock) throw new RangeError('patch is missing clock field');\n\n    if (patch.clock[actor] && patch.clock[actor] > state.seq) {\n      state.seq = patch.clock[actor];\n    }\n\n    state.clock = patch.clock;\n    state.deps = patch.deps;\n    state.maxOp = Math.max(state.maxOp, patch.maxOp);\n  }\n\n  return updateRootObject(doc, updated, state);\n}\n/**\n * Creates an empty document object with no changes.\n */\n\n\nfunction init(options) {\n  if (typeof options === 'string') {\n    options = {\n      actorId: options\n    };\n  } else if (typeof options === 'undefined') {\n    options = {};\n  } else if (!isObject(options)) {\n    throw new TypeError(`Unsupported value for init() options: ${options}`);\n  }\n\n  if (!options.deferActorId) {\n    if (options.actorId === undefined) {\n      options.actorId = uuid();\n    }\n\n    checkActorId(options.actorId);\n  }\n\n  if (options.observable) {\n    const patchCallback = options.patchCallback,\n          observable = options.observable;\n\n    options.patchCallback = (patch, before, after, local, changes) => {\n      if (patchCallback) patchCallback(patch, before, after, local, changes);\n      observable.patchCallback(patch, before, after, local, changes);\n    };\n  }\n\n  const root = {},\n        cache = {\n    _root: root\n  };\n  const state = {\n    seq: 0,\n    maxOp: 0,\n    requests: [],\n    clock: {},\n    deps: []\n  };\n\n  if (options.backend) {\n    state.backendState = options.backend.init();\n    state.lastLocalChange = null;\n  }\n\n  Object.defineProperty(root, OBJECT_ID, {\n    value: '_root'\n  });\n  Object.defineProperty(root, OPTIONS, {\n    value: Object.freeze(options)\n  });\n  Object.defineProperty(root, CONFLICTS, {\n    value: Object.freeze({})\n  });\n  Object.defineProperty(root, CACHE, {\n    value: Object.freeze(cache)\n  });\n  Object.defineProperty(root, STATE, {\n    value: Object.freeze(state)\n  });\n  return Object.freeze(root);\n}\n/**\n * Returns a new document object initialized with the given state.\n */\n\n\nfunction from(initialState, options) {\n  return change(init(options), 'Initialization', doc => Object.assign(doc, initialState));\n}\n/**\n * Changes a document `doc` according to actions taken by the local user.\n * `options` is an object that can contain the following properties:\n *  - `message`: an optional descriptive string that is attached to the change.\n * If `options` is a string, it is treated as `message`.\n *\n * The actual change is made within the callback function `callback`, which is\n * given a mutable version of the document as argument. Returns a two-element\n * array `[doc, request]` where `doc` is the updated document, and `request`\n * is the change request to send to the backend. If nothing was actually\n * changed, returns the original `doc` and a `null` change request.\n */\n\n\nfunction change(doc, options, callback) {\n  if (doc[OBJECT_ID] !== '_root') {\n    throw new TypeError('The first argument to Automerge.change must be the document root');\n  }\n\n  if (doc[CHANGE]) {\n    throw new TypeError('Calls to Automerge.change cannot be nested');\n  }\n\n  if (typeof options === 'function' && callback === undefined) {\n    [options, callback] = [callback, options];\n  }\n\n  if (typeof options === 'string') {\n    options = {\n      message: options\n    };\n  }\n\n  if (options !== undefined && !isObject(options)) {\n    throw new TypeError('Unsupported type of options');\n  }\n\n  const actorId = getActorId(doc);\n\n  if (!actorId) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change');\n  }\n\n  const context = new Context(doc, actorId);\n  callback(rootObjectProxy(context));\n\n  if (Object.keys(context.updated).length === 0) {\n    // If the callback didn't change anything, return the original document object unchanged\n    return [doc, null];\n  } else {\n    return makeChange(doc, context, options);\n  }\n}\n/**\n * Triggers a new change request on the document `doc` without actually\n * modifying its data. `options` is an object as described in the documentation\n * for the `change` function. This function can be useful for acknowledging the\n * receipt of some message (as it's incorported into the `deps` field of the\n * change). Returns a two-element array `[doc, request]` where `doc` is the\n * updated document, and `request` is the change request to send to the backend.\n */\n\n\nfunction emptyChange(doc, options) {\n  if (doc[OBJECT_ID] !== '_root') {\n    throw new TypeError('The first argument to Automerge.emptyChange must be the document root');\n  }\n\n  if (typeof options === 'string') {\n    options = {\n      message: options\n    };\n  }\n\n  if (options !== undefined && !isObject(options)) {\n    throw new TypeError('Unsupported type of options');\n  }\n\n  const actorId = getActorId(doc);\n\n  if (!actorId) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change');\n  }\n\n  return makeChange(doc, new Context(doc, actorId), options);\n}\n/**\n * Applies `patch` to the document root object `doc`. This patch must come\n * from the backend; it may be the result of a local change or a remote change.\n * If it is the result of a local change, the `seq` field from the change\n * request should be included in the patch, so that we can match them up here.\n */\n\n\nfunction applyPatch(doc, patch, backendState = undefined) {\n  if (doc[OBJECT_ID] !== '_root') {\n    throw new TypeError('The first argument to Frontend.applyPatch must be the document root');\n  }\n\n  const state = copyObject(doc[STATE]);\n\n  if (doc[OPTIONS].backend) {\n    if (!backendState) {\n      throw new RangeError('applyPatch must be called with the updated backend state');\n    }\n\n    state.backendState = backendState;\n    return applyPatchToDoc(doc, patch, state, true);\n  }\n\n  let baseDoc;\n\n  if (state.requests.length > 0) {\n    baseDoc = state.requests[0].before;\n\n    if (patch.actor === getActorId(doc)) {\n      if (state.requests[0].seq !== patch.seq) {\n        throw new RangeError(`Mismatched sequence number: patch ${patch.seq} does not match next request ${state.requests[0].seq}`);\n      }\n\n      state.requests = state.requests.slice(1);\n    } else {\n      state.requests = state.requests.slice();\n    }\n  } else {\n    baseDoc = doc;\n    state.requests = [];\n  }\n\n  let newDoc = applyPatchToDoc(baseDoc, patch, state, true);\n\n  if (state.requests.length === 0) {\n    return newDoc;\n  } else {\n    state.requests[0] = copyObject(state.requests[0]);\n    state.requests[0].before = newDoc;\n    return updateRootObject(doc, {}, state);\n  }\n}\n/**\n * Returns the Automerge object ID of the given object.\n */\n\n\nfunction getObjectId(object) {\n  return object[OBJECT_ID];\n}\n/**\n * Returns the object with the given Automerge object ID. Note: when called\n * within a change callback, the returned object is read-only (not a mutable\n * proxy object).\n */\n\n\nfunction getObjectById(doc, objectId) {\n  // It would be nice to return a proxied object in a change callback.\n  // However, that requires knowing the path from the root to the current\n  // object, which we don't have if we jumped straight to the object by its ID.\n  // If we maintained an index from object ID to parent ID we could work out the path.\n  if (doc[CHANGE]) {\n    throw new TypeError('Cannot use getObjectById in a change callback');\n  }\n\n  return doc[CACHE][objectId];\n}\n/**\n * Returns the Automerge actor ID of the given document.\n */\n\n\nfunction getActorId(doc) {\n  return doc[STATE].actorId || doc[OPTIONS].actorId;\n}\n/**\n * Sets the Automerge actor ID on the document object `doc`, returning a\n * document object with updated metadata.\n */\n\n\nfunction setActorId(doc, actorId) {\n  checkActorId(actorId);\n  const state = Object.assign({}, doc[STATE], {\n    actorId\n  });\n  return updateRootObject(doc, {}, state);\n}\n/**\n * Fetches the conflicts on the property `key` of `object`, which may be any\n * object in a document. If `object` is a list, then `key` must be a list\n * index; if `object` is a map, then `key` must be a property name.\n */\n\n\nfunction getConflicts(object, key) {\n  if (object[CONFLICTS] && object[CONFLICTS][key] && Object.keys(object[CONFLICTS][key]).length > 1) {\n    return object[CONFLICTS][key];\n  }\n}\n/**\n * Returns the backend state associated with the document `doc` (only used if\n * a backend implementation is passed to `init()`).\n */\n\n\nfunction getBackendState(doc, callerName = null, argPos = 'first') {\n  if (doc[OBJECT_ID] !== '_root') {\n    // Most likely cause of passing an array here is forgetting to deconstruct the return value of\n    // Automerge.applyChanges().\n    const extraMsg = Array.isArray(doc) ? '. Note: Automerge.applyChanges now returns an array.' : '';\n\n    if (callerName) {\n      throw new TypeError(`The ${argPos} argument to Automerge.${callerName} must be the document root${extraMsg}`);\n    } else {\n      throw new TypeError(`Argument is not an Automerge document root${extraMsg}`);\n    }\n  }\n\n  return doc[STATE].backendState;\n}\n/**\n * Given an array or text object from an Automerge document, returns an array\n * containing the unique element ID of each list element/character.\n */\n\n\nfunction getElementIds(list) {\n  if (list instanceof Text) {\n    return list.elems.map(elem => elem.elemId);\n  } else {\n    return list[ELEM_IDS];\n  }\n}\n\nmodule.exports = {\n  init,\n  from,\n  change,\n  emptyChange,\n  applyPatch,\n  getObjectId,\n  getObjectById,\n  getActorId,\n  setActorId,\n  getConflicts,\n  getLastLocalChange,\n  getBackendState,\n  getElementIds,\n  Text,\n  Table,\n  Counter,\n  Observable,\n  Float64,\n  Int,\n  Uint\n};","map":null,"metadata":{},"sourceType":"script"}