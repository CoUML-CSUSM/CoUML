{"ast":null,"code":"function isObject(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\n/**\n * Returns a shallow copy of the object `obj`. Faster than `Object.assign({}, obj)`.\n * https://jsperf.com/cloning-large-objects/1\n */\n\n\nfunction copyObject(obj) {\n  if (!isObject(obj)) return {};\n  let copy = {};\n\n  for (let key of Object.keys(obj)) {\n    copy[key] = obj[key];\n  }\n\n  return copy;\n}\n/**\n * Takes a string in the form that is used to identify operations (a counter concatenated\n * with an actor ID, separated by an `@` sign) and returns an object `{counter, actorId}`.\n */\n\n\nfunction parseOpId(opId) {\n  const match = /^(\\d+)@(.*)$/.exec(opId || '');\n\n  if (!match) {\n    throw new RangeError(`Not a valid opId: ${opId}`);\n  }\n\n  return {\n    counter: parseInt(match[1], 10),\n    actorId: match[2]\n  };\n}\n/**\n * Returns true if the two byte arrays contain the same data, false if not.\n */\n\n\nfunction equalBytes(array1, array2) {\n  if (!(array1 instanceof Uint8Array) || !(array2 instanceof Uint8Array)) {\n    throw new TypeError('equalBytes can only compare Uint8Arrays');\n  }\n\n  if (array1.byteLength !== array2.byteLength) return false;\n\n  for (let i = 0; i < array1.byteLength; i++) {\n    if (array1[i] !== array2[i]) return false;\n  }\n\n  return true;\n}\n/**\n * Creates an array containing the value `null` repeated `length` times.\n */\n\n\nfunction createArrayOfNulls(length) {\n  const array = new Array(length);\n\n  for (let i = 0; i < length; i++) array[i] = null;\n\n  return array;\n}\n\nmodule.exports = {\n  isObject,\n  copyObject,\n  parseOpId,\n  equalBytes,\n  createArrayOfNulls\n};","map":null,"metadata":{},"sourceType":"script"}