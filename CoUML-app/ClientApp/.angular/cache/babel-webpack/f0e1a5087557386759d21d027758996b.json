{"ast":null,"code":"const uuid = require('./uuid');\n\nconst Frontend = require('../frontend');\n\nconst {\n  OPTIONS\n} = require('../frontend/constants');\n\nconst {\n  encodeChange,\n  decodeChange\n} = require('../backend/columnar');\n\nconst {\n  isObject\n} = require('./common');\n\nlet backend = require('../backend'); // mutable: can be overridden with setDefaultBackend()\n\n/**\n * Automerge.* API\n * The functions in this file constitute the publicly facing Automerge API which combines\n * the features of the Frontend (a document interface) and the backend (CRDT operations)\n */\n\n\nfunction init(options) {\n  if (typeof options === 'string') {\n    options = {\n      actorId: options\n    };\n  } else if (typeof options === 'undefined') {\n    options = {};\n  } else if (!isObject(options)) {\n    throw new TypeError(`Unsupported options for init(): ${options}`);\n  }\n\n  return Frontend.init(Object.assign({\n    backend\n  }, options));\n}\n/**\n * Returns a new document object initialized with the given state.\n */\n\n\nfunction from(initialState, options) {\n  const changeOpts = {\n    message: 'Initialization'\n  };\n  return change(init(options), changeOpts, doc => Object.assign(doc, initialState));\n}\n\nfunction change(doc, options, callback) {\n  const [newDoc] = Frontend.change(doc, options, callback);\n  return newDoc;\n}\n\nfunction emptyChange(doc, options) {\n  const [newDoc] = Frontend.emptyChange(doc, options);\n  return newDoc;\n}\n\nfunction clone(doc, options = {}) {\n  const state = backend.clone(Frontend.getBackendState(doc, 'clone'));\n  return applyPatch(init(options), backend.getPatch(state), state, [], options);\n}\n\nfunction free(doc) {\n  backend.free(Frontend.getBackendState(doc, 'free'));\n}\n\nfunction load(data, options = {}) {\n  const state = backend.load(data);\n  return applyPatch(init(options), backend.getPatch(state), state, [data], options);\n}\n\nfunction save(doc) {\n  return backend.save(Frontend.getBackendState(doc, 'save'));\n}\n\nfunction merge(localDoc, remoteDoc) {\n  const localState = Frontend.getBackendState(localDoc, 'merge');\n  const remoteState = Frontend.getBackendState(remoteDoc, 'merge', 'second');\n\n  if (Frontend.getActorId(localDoc) === Frontend.getActorId(remoteDoc)) {\n    throw new RangeError('Cannot merge an actor with itself');\n  }\n\n  const changes = backend.getChangesAdded(localState, remoteState);\n  const [updatedDoc] = applyChanges(localDoc, changes);\n  return updatedDoc;\n}\n\nfunction getChanges(oldDoc, newDoc) {\n  const oldState = Frontend.getBackendState(oldDoc, 'getChanges');\n  const newState = Frontend.getBackendState(newDoc, 'getChanges', 'second');\n  return backend.getChanges(newState, backend.getHeads(oldState));\n}\n\nfunction getAllChanges(doc) {\n  return backend.getAllChanges(Frontend.getBackendState(doc, 'getAllChanges'));\n}\n\nfunction applyPatch(doc, patch, backendState, changes, options) {\n  const newDoc = Frontend.applyPatch(doc, patch, backendState);\n  const patchCallback = options.patchCallback || doc[OPTIONS].patchCallback;\n\n  if (patchCallback) {\n    patchCallback(patch, doc, newDoc, false, changes);\n  }\n\n  return newDoc;\n}\n\nfunction applyChanges(doc, changes, options = {}) {\n  const oldState = Frontend.getBackendState(doc, 'applyChanges');\n  const [newState, patch] = backend.applyChanges(oldState, changes);\n  return [applyPatch(doc, patch, newState, changes, options), patch];\n}\n\nfunction equals(val1, val2) {\n  if (!isObject(val1) || !isObject(val2)) return val1 === val2;\n  const keys1 = Object.keys(val1).sort(),\n        keys2 = Object.keys(val2).sort();\n  if (keys1.length !== keys2.length) return false;\n\n  for (let i = 0; i < keys1.length; i++) {\n    if (keys1[i] !== keys2[i]) return false;\n    if (!equals(val1[keys1[i]], val2[keys2[i]])) return false;\n  }\n\n  return true;\n}\n\nfunction getHistory(doc) {\n  const actor = Frontend.getActorId(doc);\n  const history = getAllChanges(doc);\n  return history.map((change, index) => ({\n    get change() {\n      return decodeChange(change);\n    },\n\n    get snapshot() {\n      const state = backend.loadChanges(backend.init(), history.slice(0, index + 1));\n      return Frontend.applyPatch(init(actor), backend.getPatch(state), state);\n    }\n\n  }));\n}\n\nfunction generateSyncMessage(doc, syncState) {\n  const state = Frontend.getBackendState(doc, 'generateSyncMessage');\n  return backend.generateSyncMessage(state, syncState);\n}\n\nfunction receiveSyncMessage(doc, oldSyncState, message) {\n  const oldBackendState = Frontend.getBackendState(doc, 'receiveSyncMessage');\n  const [backendState, syncState, patch] = backend.receiveSyncMessage(oldBackendState, oldSyncState, message);\n  if (!patch) return [doc, syncState, patch]; // The patchCallback is passed as argument all changes that are applied.\n  // We get those from the sync message if a patchCallback is present.\n\n  let changes = null;\n\n  if (doc[OPTIONS].patchCallback) {\n    changes = backend.decodeSyncMessage(message).changes;\n  }\n\n  return [applyPatch(doc, patch, backendState, changes, {}), syncState, patch];\n}\n\nfunction initSyncState() {\n  return backend.initSyncState();\n}\n/**\n * Replaces the default backend implementation with a different one.\n * This allows you to switch to using the Rust/WebAssembly implementation.\n */\n\n\nfunction setDefaultBackend(newBackend) {\n  backend = newBackend;\n}\n\nmodule.exports = {\n  init,\n  from,\n  change,\n  emptyChange,\n  clone,\n  free,\n  load,\n  save,\n  merge,\n  getChanges,\n  getAllChanges,\n  applyChanges,\n  encodeChange,\n  decodeChange,\n  equals,\n  getHistory,\n  uuid,\n  Frontend,\n  setDefaultBackend,\n  generateSyncMessage,\n  receiveSyncMessage,\n  initSyncState,\n\n  get Backend() {\n    return backend;\n  }\n\n};\n\nfor (let name of ['getObjectId', 'getObjectById', 'getActorId', 'setActorId', 'getConflicts', 'getLastLocalChange', 'Text', 'Table', 'Counter', 'Observable', 'Int', 'Uint', 'Float64']) {\n  module.exports[name] = Frontend[name];\n}","map":null,"metadata":{},"sourceType":"script"}