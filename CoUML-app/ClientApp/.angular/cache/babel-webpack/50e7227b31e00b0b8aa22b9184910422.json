{"ast":null,"code":"const {\n  encodeChange\n} = require('./columnar');\n\nconst {\n  BackendDoc\n} = require('./new');\n\nconst {\n  backendState\n} = require('./util');\n/**\n * Returns an empty node state.\n */\n\n\nfunction init() {\n  return {\n    state: new BackendDoc(),\n    heads: []\n  };\n}\n\nfunction clone(backend) {\n  return {\n    state: backendState(backend).clone(),\n    heads: backend.heads\n  };\n}\n\nfunction free(backend) {\n  backend.state = null;\n  backend.frozen = true;\n}\n/**\n * Applies a list of `changes` from remote nodes to the node state `backend`.\n * Returns a two-element array `[state, patch]` where `state` is the updated\n * node state, and `patch` describes the modifications that need to be made\n * to the document objects to reflect these changes.\n */\n\n\nfunction applyChanges(backend, changes) {\n  const state = backendState(backend);\n  const patch = state.applyChanges(changes);\n  backend.frozen = true;\n  return [{\n    state,\n    heads: state.heads\n  }, patch];\n}\n\nfunction hashByActor(state, actorId, index) {\n  if (state.hashesByActor[actorId] && state.hashesByActor[actorId][index]) {\n    return state.hashesByActor[actorId][index];\n  }\n\n  if (!state.haveHashGraph) {\n    state.computeHashGraph();\n\n    if (state.hashesByActor[actorId] && state.hashesByActor[actorId][index]) {\n      return state.hashesByActor[actorId][index];\n    }\n  }\n\n  throw new RangeError(`Unknown change: actorId = ${actorId}, seq = ${index + 1}`);\n}\n/**\n * Takes a single change request `request` made by the local user, and applies\n * it to the node state `backend`. Returns a three-element array `[backend, patch, binaryChange]`\n * where `backend` is the updated node state,`patch` confirms the\n * modifications to the document objects, and `binaryChange` is a binary-encoded form of\n * the change submitted.\n */\n\n\nfunction applyLocalChange(backend, change) {\n  const state = backendState(backend);\n\n  if (change.seq <= state.clock[change.actor] || 0) {\n    throw new RangeError('Change request has already been applied');\n  } // Add the local actor's last change hash to deps. We do this because when frontend\n  // and backend are on separate threads, the frontend may fire off several local\n  // changes in sequence before getting a response from the backend; since the binary\n  // encoding and hashing is done by the backend, the frontend does not know the hash\n  // of its own last change in this case. Rather than handle this situation as a\n  // special case, we say that the frontend includes only specifies other actors'\n  // deps in changes it generates, and the dependency from the local actor's last\n  // change is always added here in the backend.\n  //\n  // Strictly speaking, we should check whether the local actor's last change is\n  // indirectly reachable through a different actor's change; in that case, it is not\n  // necessary to add this dependency. However, it doesn't do any harm either (only\n  // using a few extra bytes of storage).\n\n\n  if (change.seq > 1) {\n    const lastHash = hashByActor(state, change.actor, change.seq - 2);\n\n    if (!lastHash) {\n      throw new RangeError(`Cannot find hash of localChange before seq=${change.seq}`);\n    }\n\n    let deps = {\n      [lastHash]: true\n    };\n\n    for (let hash of change.deps) deps[hash] = true;\n\n    change.deps = Object.keys(deps).sort();\n  }\n\n  const binaryChange = encodeChange(change);\n  const patch = state.applyChanges([binaryChange], true);\n  backend.frozen = true; // On the patch we send out, omit the last local change hash\n\n  const lastHash = hashByActor(state, change.actor, change.seq - 1);\n  patch.deps = patch.deps.filter(head => head !== lastHash);\n  return [{\n    state,\n    heads: state.heads\n  }, patch, binaryChange];\n}\n/**\n * Returns the state of the document serialised to an Uint8Array.\n */\n\n\nfunction save(backend) {\n  return backendState(backend).save();\n}\n/**\n * Loads the document and/or changes contained in an Uint8Array, and returns a\n * backend initialised with this state.\n */\n\n\nfunction load(data) {\n  const state = new BackendDoc(data);\n  return {\n    state,\n    heads: state.heads\n  };\n}\n/**\n * Applies a list of `changes` to the node state `backend`, and returns the updated\n * state with those changes incorporated. Unlike `applyChanges()`, this function\n * does not produce a patch describing the incremental modifications, making it\n * a little faster when loading a document from disk. When all the changes have\n * been loaded, you can use `getPatch()` to construct the latest document state.\n */\n\n\nfunction loadChanges(backend, changes) {\n  const state = backendState(backend);\n  state.applyChanges(changes);\n  backend.frozen = true;\n  return {\n    state,\n    heads: state.heads\n  };\n}\n/**\n * Returns a patch that, when applied to an empty document, constructs the\n * document tree in the state described by the node state `backend`.\n */\n\n\nfunction getPatch(backend) {\n  return backendState(backend).getPatch();\n}\n/**\n * Returns an array of hashes of the current \"head\" changes (i.e. those changes\n * that no other change depends on).\n */\n\n\nfunction getHeads(backend) {\n  return backend.heads;\n}\n/**\n * Returns the full history of changes that have been applied to a document.\n */\n\n\nfunction getAllChanges(backend) {\n  return getChanges(backend, []);\n}\n/**\n * Returns all changes that are newer than or concurrent to the changes\n * identified by the hashes in `haveDeps`. If `haveDeps` is an empty array, all\n * changes are returned. Throws an exception if any of the given hashes is unknown.\n */\n\n\nfunction getChanges(backend, haveDeps) {\n  if (!Array.isArray(haveDeps)) {\n    throw new TypeError('Pass an array of hashes to Backend.getChanges()');\n  }\n\n  return backendState(backend).getChanges(haveDeps);\n}\n/**\n * Returns all changes that are present in `backend2` but not in `backend1`.\n * Intended for use in situations where the two backends are for different actors.\n * To get the changes added between an older and a newer document state of the same\n * actor, use `getChanges()` instead. `getChangesAdded()` throws an exception if\n * one of the backend states is frozen (i.e. if it is not the latest state of that\n * backend instance; this distinction matters when the backend is mutable).\n */\n\n\nfunction getChangesAdded(backend1, backend2) {\n  return backendState(backend2).getChangesAdded(backendState(backend1));\n}\n/**\n * If the backend has applied a change with the given `hash` (given as a\n * hexadecimal string), returns that change (as a byte array). Returns undefined\n * if no change with that hash has been applied. A change with missing\n * dependencies does not count as having been applied.\n */\n\n\nfunction getChangeByHash(backend, hash) {\n  return backendState(backend).getChangeByHash(hash);\n}\n/**\n * Returns the hashes of any missing dependencies, i.e. where we have applied a\n * change that has a dependency on a change we have not seen.\n *\n * If the argument `heads` is given (an array of hexadecimal strings representing\n * hashes as returned by `getHeads()`), this function also ensures that all of\n * those hashes resolve to either a change that has been applied to the document,\n * or that has been enqueued for later application once missing dependencies have\n * arrived. Any missing heads hashes are included in the returned array.\n */\n\n\nfunction getMissingDeps(backend, heads = []) {\n  return backendState(backend).getMissingDeps(heads);\n}\n\nmodule.exports = {\n  init,\n  clone,\n  free,\n  applyChanges,\n  applyLocalChange,\n  save,\n  load,\n  loadChanges,\n  getPatch,\n  getHeads,\n  getAllChanges,\n  getChanges,\n  getChangesAdded,\n  getChangeByHash,\n  getMissingDeps\n};","map":null,"metadata":{},"sourceType":"script"}