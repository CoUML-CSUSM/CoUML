{"ast":null,"code":"const {\n  OBJECT_ID,\n  CONFLICTS\n} = require('./constants');\n/**\n * Allows an application to register a callback when a particular object in\n * a document changes.\n *\n * NOTE: This API is experimental and may change without warning in minor releases.\n */\n\n\nclass Observable {\n  constructor() {\n    this.observers = {}; // map from objectId to array of observers for that object\n  }\n  /**\n   * Called by an Automerge document when `patch` is applied. `before` is the\n   * state of the document before the patch, and `after` is the state after\n   * applying it. `local` is true if the update is a result of locally calling\n   * `Automerge.change()`, and false otherwise. `changes` is an array of\n   * changes that were applied to the document (as Uint8Arrays).\n   */\n\n\n  patchCallback(patch, before, after, local, changes) {\n    this._objectUpdate(patch.diffs, before, after, local, changes);\n  }\n  /**\n   * Recursively walks a patch and calls the callbacks for all objects that\n   * appear in the patch.\n   */\n\n\n  _objectUpdate(diff, before, after, local, changes) {\n    if (!diff.objectId) return;\n\n    if (this.observers[diff.objectId]) {\n      for (let callback of this.observers[diff.objectId]) {\n        callback(diff, before, after, local, changes);\n      }\n    }\n\n    if (diff.type === 'map' && diff.props) {\n      for (const propName of Object.keys(diff.props)) {\n        for (const opId of Object.keys(diff.props[propName])) {\n          this._objectUpdate(diff.props[propName][opId], before && before[CONFLICTS] && before[CONFLICTS][propName] && before[CONFLICTS][propName][opId], after && after[CONFLICTS] && after[CONFLICTS][propName] && after[CONFLICTS][propName][opId], local, changes);\n        }\n      }\n    } else if (diff.type === 'table' && diff.props) {\n      for (const rowId of Object.keys(diff.props)) {\n        for (const opId of Object.keys(diff.props[rowId])) {\n          this._objectUpdate(diff.props[rowId][opId], before && before.byId(rowId), after && after.byId(rowId), local, changes);\n        }\n      }\n    } else if (diff.type === 'list' && diff.edits) {\n      let offset = 0;\n\n      for (const edit of diff.edits) {\n        if (edit.action === 'insert') {\n          offset -= 1;\n\n          this._objectUpdate(edit.value, undefined, after && after[CONFLICTS] && after[CONFLICTS][edit.index] && after[CONFLICTS][edit.index][edit.elemId], local, changes);\n        } else if (edit.action === 'multi-insert') {\n          offset -= edit.values.length;\n        } else if (edit.action === 'update') {\n          this._objectUpdate(edit.value, before && before[CONFLICTS] && before[CONFLICTS][edit.index + offset] && before[CONFLICTS][edit.index + offset][edit.opId], after && after[CONFLICTS] && after[CONFLICTS][edit.index] && after[CONFLICTS][edit.index][edit.opId], local, changes);\n        } else if (edit.action === 'remove') {\n          offset += edit.count;\n        }\n      }\n    } else if (diff.type === 'text' && diff.edits) {\n      let offset = 0;\n\n      for (const edit of diff.edits) {\n        if (edit.action === 'insert') {\n          offset -= 1;\n\n          this._objectUpdate(edit.value, undefined, after && after.get(edit.index), local, changes);\n        } else if (edit.action === 'multi-insert') {\n          offset -= edit.values.length;\n        } else if (edit.action === 'update') {\n          this._objectUpdate(edit.value, before && before.get(edit.index + offset), after && after.get(edit.index), local, changes);\n        } else if (edit.action === 'remove') {\n          offset += edit.count;\n        }\n      }\n    }\n  }\n  /**\n   * Call this to register a callback that will get called whenever a particular\n   * object in a document changes. The callback is passed five arguments: the\n   * part of the patch describing the update to that object, the old state of\n   * the object, the new state of the object, a boolean that is true if the\n   * change is the result of calling `Automerge.change()` locally, and the array\n   * of binary changes applied to the document.\n   */\n\n\n  observe(object, callback) {\n    const objectId = object[OBJECT_ID];\n    if (!objectId) throw new TypeError('The observed object must be part of an Automerge document');\n    if (!this.observers[objectId]) this.observers[objectId] = [];\n    this.observers[objectId].push(callback);\n  }\n\n}\n\nmodule.exports = {\n  Observable\n};","map":null,"metadata":{},"sourceType":"script"}