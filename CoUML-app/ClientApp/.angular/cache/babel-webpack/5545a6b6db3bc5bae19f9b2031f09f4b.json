{"ast":null,"code":"const {\n  CACHE,\n  OBJECT_ID,\n  CONFLICTS,\n  ELEM_IDS,\n  STATE\n} = require('./constants');\n\nconst {\n  interpretPatch\n} = require('./apply_patch');\n\nconst {\n  Text\n} = require('./text');\n\nconst {\n  Table\n} = require('./table');\n\nconst {\n  Counter,\n  getWriteableCounter\n} = require('./counter');\n\nconst {\n  Int,\n  Uint,\n  Float64\n} = require('./numbers');\n\nconst {\n  isObject,\n  parseOpId,\n  createArrayOfNulls\n} = require('../src/common');\n\nconst uuid = require('../src/uuid');\n/**\n * An instance of this class is passed to `rootObjectProxy()`. The methods are\n * called by proxy object mutation functions to query the current object state\n * and to apply the requested changes.\n */\n\n\nclass Context {\n  constructor(doc, actorId, applyPatch) {\n    this.actorId = actorId;\n    this.nextOpNum = doc[STATE].maxOp + 1;\n    this.cache = doc[CACHE];\n    this.updated = {};\n    this.ops = [];\n    this.applyPatch = applyPatch ? applyPatch : interpretPatch;\n  }\n  /**\n   * Adds an operation object to the list of changes made in the current context.\n   */\n\n\n  addOp(operation) {\n    this.ops.push(operation);\n\n    if (operation.action === 'set' && operation.values) {\n      this.nextOpNum += operation.values.length;\n    } else if (operation.action === 'del' && operation.multiOp) {\n      this.nextOpNum += operation.multiOp;\n    } else {\n      this.nextOpNum += 1;\n    }\n  }\n  /**\n   * Returns the operation ID of the next operation to be added to the context.\n   */\n\n\n  nextOpId() {\n    return `${this.nextOpNum}@${this.actorId}`;\n  }\n  /**\n   * Takes a value and returns an object describing the value (in the format used by patches).\n   */\n\n\n  getValueDescription(value) {\n    if (!['object', 'boolean', 'number', 'string'].includes(typeof value)) {\n      throw new TypeError(`Unsupported type of value: ${typeof value}`);\n    }\n\n    if (isObject(value)) {\n      if (value instanceof Date) {\n        // Date object, represented as milliseconds since epoch\n        return {\n          type: 'value',\n          value: value.getTime(),\n          datatype: 'timestamp'\n        };\n      } else if (value instanceof Int) {\n        return {\n          type: 'value',\n          value: value.value,\n          datatype: 'int'\n        };\n      } else if (value instanceof Uint) {\n        return {\n          type: 'value',\n          value: value.value,\n          datatype: 'uint'\n        };\n      } else if (value instanceof Float64) {\n        return {\n          type: 'value',\n          value: value.value,\n          datatype: 'float64'\n        };\n      } else if (value instanceof Counter) {\n        // Counter object\n        return {\n          type: 'value',\n          value: value.value,\n          datatype: 'counter'\n        };\n      } else {\n        // Nested object (map, list, text, or table)\n        const objectId = value[OBJECT_ID],\n              type = this.getObjectType(objectId);\n\n        if (!objectId) {\n          throw new RangeError(`Object ${JSON.stringify(value)} has no objectId`);\n        }\n\n        if (type === 'list' || type === 'text') {\n          return {\n            objectId,\n            type,\n            edits: []\n          };\n        } else {\n          return {\n            objectId,\n            type,\n            props: {}\n          };\n        }\n      }\n    } else if (typeof value === 'number') {\n      if (Number.isInteger(value) && value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER) {\n        return {\n          type: 'value',\n          value,\n          datatype: 'int'\n        };\n      } else {\n        return {\n          type: 'value',\n          value,\n          datatype: 'float64'\n        };\n      }\n    } else {\n      // Primitive value (string, boolean, or null)\n      return {\n        type: 'value',\n        value\n      };\n    }\n  }\n  /**\n   * Builds the values structure describing a single property in a patch. Finds all the values of\n   * property `key` of `object` (there might be multiple values in the case of a conflict), and\n   * returns an object that maps operation IDs to descriptions of values.\n   */\n\n\n  getValuesDescriptions(path, object, key) {\n    if (object instanceof Table) {\n      // Table objects don't have conflicts, since rows are identified by their unique objectId\n      const value = object.byId(key);\n      return value ? {\n        [key]: this.getValueDescription(value)\n      } : {};\n    } else if (object instanceof Text) {\n      // Text objects don't support conflicts\n      const value = object.get(key);\n      const elemId = object.getElemId(key);\n      return value ? {\n        [elemId]: this.getValueDescription(value)\n      } : {};\n    } else {\n      // Map or list objects\n      const conflicts = object[CONFLICTS][key],\n            values = {};\n\n      if (!conflicts) {\n        throw new RangeError(`No children at key ${key} of path ${JSON.stringify(path)}`);\n      }\n\n      for (let opId of Object.keys(conflicts)) {\n        values[opId] = this.getValueDescription(conflicts[opId]);\n      }\n\n      return values;\n    }\n  }\n  /**\n   * Returns the value at property `key` of object `object`. In the case of a conflict, returns\n   * the value whose assignment operation has the ID `opId`.\n   */\n\n\n  getPropertyValue(object, key, opId) {\n    if (object instanceof Table) {\n      return object.byId(key);\n    } else if (object instanceof Text) {\n      return object.get(key);\n    } else {\n      return object[CONFLICTS][key][opId];\n    }\n  }\n  /**\n   * Recurses along `path` into the patch object `patch`, creating nodes along the way as needed\n   * by mutating the patch object. Returns the subpatch at the given path.\n   */\n\n\n  getSubpatch(patch, path) {\n    if (path.length == 0) return patch;\n    let subpatch = patch,\n        object = this.getObject('_root');\n\n    for (let pathElem of path) {\n      let values = this.getValuesDescriptions(path, object, pathElem.key);\n\n      if (subpatch.props) {\n        if (!subpatch.props[pathElem.key]) {\n          subpatch.props[pathElem.key] = values;\n        }\n      } else if (subpatch.edits) {\n        for (const opId of Object.keys(values)) {\n          subpatch.edits.push({\n            action: 'update',\n            index: pathElem.key,\n            opId,\n            value: values[opId]\n          });\n        }\n      }\n\n      let nextOpId = null;\n\n      for (let opId of Object.keys(values)) {\n        if (values[opId].objectId === pathElem.objectId) {\n          nextOpId = opId;\n        }\n      }\n\n      if (!nextOpId) {\n        throw new RangeError(`Cannot find path object with objectId ${pathElem.objectId}`);\n      }\n\n      subpatch = values[nextOpId];\n      object = this.getPropertyValue(object, pathElem.key, nextOpId);\n    }\n\n    return subpatch;\n  }\n  /**\n   * Returns an object (not proxied) from the cache or updated set, as appropriate.\n   */\n\n\n  getObject(objectId) {\n    const object = this.updated[objectId] || this.cache[objectId];\n    if (!object) throw new RangeError(`Target object does not exist: ${objectId}`);\n    return object;\n  }\n  /**\n   * Returns a string that is either 'map', 'table', 'list', or 'text', indicating\n   * the type of the object with ID `objectId`.\n   */\n\n\n  getObjectType(objectId) {\n    if (objectId === '_root') return 'map';\n    const object = this.getObject(objectId);\n    if (object instanceof Text) return 'text';\n    if (object instanceof Table) return 'table';\n    if (Array.isArray(object)) return 'list';\n    return 'map';\n  }\n  /**\n   * Returns the value associated with the property named `key` on the object\n   * at path `path`. If the value is an object, returns a proxy for it.\n   */\n\n\n  getObjectField(path, objectId, key) {\n    if (!['string', 'number'].includes(typeof key)) return;\n    const object = this.getObject(objectId);\n\n    if (object[key] instanceof Counter) {\n      return getWriteableCounter(object[key].value, this, path, objectId, key);\n    } else if (isObject(object[key])) {\n      const childId = object[key][OBJECT_ID];\n      const subpath = path.concat([{\n        key,\n        objectId: childId\n      }]); // The instantiateObject function is added to the context object by rootObjectProxy()\n\n      return this.instantiateObject(subpath, childId);\n    } else {\n      return object[key];\n    }\n  }\n  /**\n   * Recursively creates Automerge versions of all the objects and nested objects in `value`,\n   * constructing a patch and operations that describe the object tree. The new object is\n   * assigned to the property `key` in the object with ID `obj`. If the object is a list or\n   * text, `key` must be set to the list index being updated, and `elemId` must be set to the\n   * elemId of the element being updated. If `insert` is true, we insert a new list element\n   * (or text character) at index `key`, and `elemId` must be the elemId of the immediate\n   * predecessor element (or the string '_head' if inserting at index 0). If the assignment\n   * overwrites a previous value at this key/element, `pred` must be set to the array of the\n   * prior operations we are overwriting (empty array if there is no existing value).\n   */\n\n\n  createNestedObjects(obj, key, value, insert, pred, elemId) {\n    if (value[OBJECT_ID]) {\n      throw new RangeError('Cannot create a reference to an existing document object');\n    }\n\n    const objectId = this.nextOpId();\n\n    if (value instanceof Text) {\n      // Create a new Text object\n      this.addOp(elemId ? {\n        action: 'makeText',\n        obj,\n        elemId,\n        insert,\n        pred\n      } : {\n        action: 'makeText',\n        obj,\n        key,\n        insert,\n        pred\n      });\n      const subpatch = {\n        objectId,\n        type: 'text',\n        edits: []\n      };\n      this.insertListItems(subpatch, 0, [...value], true);\n      return subpatch;\n    } else if (value instanceof Table) {\n      // Create a new Table object\n      if (value.count > 0) {\n        throw new RangeError('Assigning a non-empty Table object is not supported');\n      }\n\n      this.addOp(elemId ? {\n        action: 'makeTable',\n        obj,\n        elemId,\n        insert,\n        pred\n      } : {\n        action: 'makeTable',\n        obj,\n        key,\n        insert,\n        pred\n      });\n      return {\n        objectId,\n        type: 'table',\n        props: {}\n      };\n    } else if (Array.isArray(value)) {\n      // Create a new list object\n      this.addOp(elemId ? {\n        action: 'makeList',\n        obj,\n        elemId,\n        insert,\n        pred\n      } : {\n        action: 'makeList',\n        obj,\n        key,\n        insert,\n        pred\n      });\n      const subpatch = {\n        objectId,\n        type: 'list',\n        edits: []\n      };\n      this.insertListItems(subpatch, 0, value, true);\n      return subpatch;\n    } else {\n      // Create a new map object\n      this.addOp(elemId ? {\n        action: 'makeMap',\n        obj,\n        elemId,\n        insert,\n        pred\n      } : {\n        action: 'makeMap',\n        obj,\n        key,\n        insert,\n        pred\n      });\n      let props = {};\n\n      for (let nested of Object.keys(value).sort()) {\n        const opId = this.nextOpId();\n        const valuePatch = this.setValue(objectId, nested, value[nested], false, []);\n        props[nested] = {\n          [opId]: valuePatch\n        };\n      }\n\n      return {\n        objectId,\n        type: 'map',\n        props\n      };\n    }\n  }\n  /**\n   * Records an assignment to a particular key in a map, or a particular index in a list.\n   * `objectId` is the ID of the object being modified, `key` is the property name or list\n   * index being updated, and `value` is the new value being assigned. If `insert` is true,\n   * a new list element is inserted at index `key`, and `value` is assigned to that new list\n   * element. `pred` is an array of opIds for previous values of the property being assigned,\n   * which are overwritten by this operation. If the object being modified is a list or text,\n   * `elemId` is the element ID of the list element being updated (if insert=false), or the\n   * element ID of the list element immediately preceding the insertion (if insert=true).\n   *\n   * Returns a patch describing the new value. The return value is of the form\n   * `{objectId, type, props}` if `value` is an object, or `{value, datatype}` if it is a\n   * primitive value. For string, number, boolean, or null the datatype is omitted.\n   */\n\n\n  setValue(objectId, key, value, insert, pred, elemId) {\n    if (!objectId) {\n      throw new RangeError('setValue needs an objectId');\n    }\n\n    if (key === '') {\n      throw new RangeError('The key of a map entry must not be an empty string');\n    }\n\n    if (isObject(value) && !(value instanceof Date) && !(value instanceof Counter) && !(value instanceof Int) && !(value instanceof Uint) && !(value instanceof Float64)) {\n      // Nested object (map, list, text, or table)\n      return this.createNestedObjects(objectId, key, value, insert, pred, elemId);\n    } else {\n      // Date or counter object, or primitive value (number, string, boolean, or null)\n      const description = this.getValueDescription(value);\n      const op = {\n        action: 'set',\n        obj: objectId,\n        insert,\n        value: description.value,\n        pred\n      };\n      if (elemId) op.elemId = elemId;else op.key = key;\n      if (description.datatype) op.datatype = description.datatype;\n      this.addOp(op);\n      return description;\n    }\n  }\n  /**\n   * Constructs a new patch, calls `callback` with the subpatch at the location `path`,\n   * and then immediately applies the patch to the document.\n   */\n\n\n  applyAtPath(path, callback) {\n    let diff = {\n      objectId: '_root',\n      type: 'map',\n      props: {}\n    };\n    callback(this.getSubpatch(diff, path));\n    this.applyPatch(diff, this.cache._root, this.updated);\n  }\n  /**\n   * Updates the map object at path `path`, setting the property with name\n   * `key` to `value`.\n   */\n\n\n  setMapKey(path, key, value) {\n    if (typeof key !== 'string') {\n      throw new RangeError(`The key of a map entry must be a string, not ${typeof key}`);\n    }\n\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId;\n    const object = this.getObject(objectId);\n\n    if (object[key] instanceof Counter) {\n      throw new RangeError('Cannot overwrite a Counter object; use .increment() or .decrement() to change its value.');\n    } // If the assigned field value is the same as the existing value, and\n    // the assignment does not resolve a conflict, do nothing\n\n\n    if (object[key] !== value || Object.keys(object[CONFLICTS][key] || {}).length > 1 || value === undefined) {\n      this.applyAtPath(path, subpatch => {\n        const pred = getPred(object, key);\n        const opId = this.nextOpId();\n        const valuePatch = this.setValue(objectId, key, value, false, pred);\n        subpatch.props[key] = {\n          [opId]: valuePatch\n        };\n      });\n    }\n  }\n  /**\n   * Updates the map object at path `path`, deleting the property `key`.\n   */\n\n\n  deleteMapKey(path, key) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId;\n    const object = this.getObject(objectId);\n\n    if (object[key] !== undefined) {\n      const pred = getPred(object, key);\n      this.addOp({\n        action: 'del',\n        obj: objectId,\n        key,\n        insert: false,\n        pred\n      });\n      this.applyAtPath(path, subpatch => {\n        subpatch.props[key] = {};\n      });\n    }\n  }\n  /**\n   * Inserts a sequence of new list elements `values` into a list, starting at position `index`.\n   * `newObject` is true if we are creating a new list object, and false if we are updating an\n   * existing one. `subpatch` is the patch for the list object being modified. Mutates\n   * `subpatch` to reflect the sequence of values.\n   */\n\n\n  insertListItems(subpatch, index, values, newObject) {\n    const list = newObject ? [] : this.getObject(subpatch.objectId);\n\n    if (index < 0 || index > list.length) {\n      throw new RangeError(`List index ${index} is out of bounds for list of length ${list.length}`);\n    }\n\n    if (values.length === 0) return;\n    let elemId = getElemId(list, index, true);\n    const allPrimitive = values.every(v => typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || v === null || isObject(v) && (v instanceof Date || v instanceof Counter || v instanceof Int || v instanceof Uint || v instanceof Float64));\n    const allValueDescriptions = allPrimitive ? values.map(v => this.getValueDescription(v)) : [];\n    const allDatatypesSame = allValueDescriptions.every(t => t.datatype === allValueDescriptions[0].datatype);\n\n    if (allPrimitive && allDatatypesSame && values.length > 1) {\n      const nextElemId = this.nextOpId();\n      const datatype = allValueDescriptions[0].datatype;\n      const values = allValueDescriptions.map(v => v.value);\n      const op = {\n        action: 'set',\n        obj: subpatch.objectId,\n        elemId,\n        insert: true,\n        values,\n        pred: []\n      };\n      const edit = {\n        action: 'multi-insert',\n        elemId: nextElemId,\n        index,\n        values\n      };\n\n      if (datatype) {\n        op.datatype = datatype;\n        edit.datatype = datatype;\n      }\n\n      this.addOp(op);\n      subpatch.edits.push(edit);\n    } else {\n      for (let offset = 0; offset < values.length; offset++) {\n        let nextElemId = this.nextOpId();\n        const valuePatch = this.setValue(subpatch.objectId, index + offset, values[offset], true, [], elemId);\n        elemId = nextElemId;\n        subpatch.edits.push({\n          action: 'insert',\n          index: index + offset,\n          elemId,\n          opId: elemId,\n          value: valuePatch\n        });\n      }\n    }\n  }\n  /**\n   * Updates the list object at path `path`, replacing the current value at\n   * position `index` with the new value `value`.\n   */\n\n\n  setListIndex(path, index, value) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId;\n    const list = this.getObject(objectId); // Assignment past the end of the list => insert nulls followed by new value\n\n    if (index >= list.length) {\n      const insertions = createArrayOfNulls(index - list.length);\n      insertions.push(value);\n      return this.splice(path, list.length, 0, insertions);\n    }\n\n    if (list[index] instanceof Counter) {\n      throw new RangeError('Cannot overwrite a Counter object; use .increment() or .decrement() to change its value.');\n    } // If the assigned list element value is the same as the existing value, and\n    // the assignment does not resolve a conflict, do nothing\n\n\n    if (list[index] !== value || Object.keys(list[CONFLICTS][index] || {}).length > 1 || value === undefined) {\n      this.applyAtPath(path, subpatch => {\n        const pred = getPred(list, index);\n        const opId = this.nextOpId();\n        const valuePatch = this.setValue(objectId, index, value, false, pred, getElemId(list, index));\n        subpatch.edits.push({\n          action: 'update',\n          index,\n          opId,\n          value: valuePatch\n        });\n      });\n    }\n  }\n  /**\n   * Updates the list object at path `path`, deleting `deletions` list elements starting from\n   * list index `start`, and inserting the list of new elements `insertions` at that position.\n   */\n\n\n  splice(path, start, deletions, insertions) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId;\n    let list = this.getObject(objectId);\n\n    if (start < 0 || deletions < 0 || start > list.length - deletions) {\n      throw new RangeError(`${deletions} deletions starting at index ${start} are out of bounds for list of length ${list.length}`);\n    }\n\n    if (deletions === 0 && insertions.length === 0) return;\n    let patch = {\n      diffs: {\n        objectId: '_root',\n        type: 'map',\n        props: {}\n      }\n    };\n    let subpatch = this.getSubpatch(patch.diffs, path);\n\n    if (deletions > 0) {\n      let op, lastElemParsed, lastPredParsed;\n\n      for (let i = 0; i < deletions; i++) {\n        if (this.getObjectField(path, objectId, start + i) instanceof Counter) {\n          // This may seem bizarre, but it's really fiddly to implement deletion of counters from\n          // lists, and I doubt anyone ever needs to do this, so I'm just going to throw an\n          // exception for now. The reason is: a counter is created by a set operation with counter\n          // datatype, and subsequent increment ops are successors to the set operation. Normally, a\n          // set operation with successor indicates a value that has been overwritten, so a set\n          // operation with successors is normally invisible. Counters are an exception, because the\n          // increment operations don't make the set operation invisible. When a counter appears in\n          // a map, this is not too bad: if all successors are increments, then the counter remains\n          // visible; if one or more successors are deletions, it goes away. However, when deleting\n          // a list element, we have the additional challenge that we need to distinguish between a\n          // list element that is being deleted by the current change (in which case we need to put\n          // a 'remove' action in the patch's edits for that list) and a list element that was\n          // already deleted previously (in which case the patch should not reflect the deletion).\n          // This can be done, but as I said, it's fiddly. If someone wants to pick this up in the\n          // future, hopefully the above description will be enough to get you started. Good luck!\n          throw new TypeError('Unsupported operation: deleting a counter from a list');\n        } // Any sequences of deletions with consecutive elemId and pred values get combined into a\n        // single multiOp; any others become individual deletion operations. This optimisation only\n        // kicks in if the user deletes a sequence of elements at once (in a single call to splice);\n        // it might be nice to also detect such runs of deletions in the case where the user deletes\n        // a sequence of list elements one by one.\n\n\n        const thisElem = getElemId(list, start + i),\n              thisElemParsed = parseOpId(thisElem);\n        const thisPred = getPred(list, start + i);\n        const thisPredParsed = thisPred.length === 1 ? parseOpId(thisPred[0]) : undefined;\n\n        if (op && lastElemParsed && lastPredParsed && thisPredParsed && lastElemParsed.actorId === thisElemParsed.actorId && lastElemParsed.counter + 1 === thisElemParsed.counter && lastPredParsed.actorId === thisPredParsed.actorId && lastPredParsed.counter + 1 === thisPredParsed.counter) {\n          op.multiOp = (op.multiOp || 1) + 1;\n        } else {\n          if (op) this.addOp(op);\n          op = {\n            action: 'del',\n            obj: objectId,\n            elemId: thisElem,\n            insert: false,\n            pred: thisPred\n          };\n        }\n\n        lastElemParsed = thisElemParsed;\n        lastPredParsed = thisPredParsed;\n      }\n\n      this.addOp(op);\n      subpatch.edits.push({\n        action: 'remove',\n        index: start,\n        count: deletions\n      });\n    }\n\n    if (insertions.length > 0) {\n      this.insertListItems(subpatch, start, insertions, false);\n    }\n\n    this.applyPatch(patch.diffs, this.cache._root, this.updated);\n  }\n  /**\n   * Updates the table object at path `path`, adding a new entry `row`.\n   * Returns the objectId of the new row.\n   */\n\n\n  addTableRow(path, row) {\n    if (!isObject(row) || Array.isArray(row)) {\n      throw new TypeError('A table row must be an object');\n    }\n\n    if (row[OBJECT_ID]) {\n      throw new TypeError('Cannot reuse an existing object as table row');\n    }\n\n    if (row.id) {\n      throw new TypeError('A table row must not have an \"id\" property; it is generated automatically');\n    }\n\n    const id = uuid();\n    const valuePatch = this.setValue(path[path.length - 1].objectId, id, row, false, []);\n    this.applyAtPath(path, subpatch => {\n      subpatch.props[id] = {\n        [valuePatch.objectId]: valuePatch\n      };\n    });\n    return id;\n  }\n  /**\n   * Updates the table object at path `path`, deleting the row with ID `rowId`.\n   * `pred` is the opId of the operation that originally created the row.\n   */\n\n\n  deleteTableRow(path, rowId, pred) {\n    const objectId = path[path.length - 1].objectId,\n          table = this.getObject(objectId);\n\n    if (table.byId(rowId)) {\n      this.addOp({\n        action: 'del',\n        obj: objectId,\n        key: rowId,\n        insert: false,\n        pred: [pred]\n      });\n      this.applyAtPath(path, subpatch => {\n        subpatch.props[rowId] = {};\n      });\n    }\n  }\n  /**\n   * Adds the integer `delta` to the value of the counter located at property\n   * `key` in the object at path `path`.\n   */\n\n\n  increment(path, key, delta) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId;\n    const object = this.getObject(objectId);\n\n    if (!(object[key] instanceof Counter)) {\n      throw new TypeError('Only counter values can be incremented');\n    } // TODO what if there is a conflicting value on the same key as the counter?\n\n\n    const type = this.getObjectType(objectId);\n    const value = object[key].value + delta;\n    const opId = this.nextOpId();\n    const pred = getPred(object, key);\n\n    if (type === 'list' || type === 'text') {\n      const elemId = getElemId(object, key, false);\n      this.addOp({\n        action: 'inc',\n        obj: objectId,\n        elemId,\n        value: delta,\n        insert: false,\n        pred\n      });\n    } else {\n      this.addOp({\n        action: 'inc',\n        obj: objectId,\n        key,\n        value: delta,\n        insert: false,\n        pred\n      });\n    }\n\n    this.applyAtPath(path, subpatch => {\n      if (type === 'list' || type === 'text') {\n        subpatch.edits.push({\n          action: 'update',\n          index: key,\n          opId,\n          value: {\n            value,\n            datatype: 'counter'\n          }\n        });\n      } else {\n        subpatch.props[key] = {\n          [opId]: {\n            value,\n            datatype: 'counter'\n          }\n        };\n      }\n    });\n  }\n\n}\n\nfunction getPred(object, key) {\n  if (object instanceof Table) {\n    return [object.opIds[key]];\n  } else if (object instanceof Text) {\n    return object.elems[key].pred;\n  } else if (object[CONFLICTS]) {\n    return object[CONFLICTS][key] ? Object.keys(object[CONFLICTS][key]) : [];\n  } else {\n    return [];\n  }\n}\n\nfunction getElemId(list, index, insert = false) {\n  if (insert) {\n    if (index === 0) return '_head';\n    index -= 1;\n  }\n\n  if (list[ELEM_IDS]) return list[ELEM_IDS][index];\n  if (list.getElemId) return list.getElemId(index);\n  throw new RangeError(`Cannot find elemId at list index ${index}`);\n}\n\nmodule.exports = {\n  Context\n};","map":null,"metadata":{},"sourceType":"script"}