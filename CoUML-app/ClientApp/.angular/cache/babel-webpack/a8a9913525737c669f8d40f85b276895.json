{"ast":null,"code":"/**\n * UTF-8 decoding and encoding using API that is supported in Node >= 12 and modern browsers:\n * https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encode\n * https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder/decode\n * If you're running in an environment where it's not available, please use a polyfill, such as:\n * https://github.com/anonyco/FastestSmallestTextEncoderDecoder\n */\nconst utf8encoder = new TextEncoder();\nconst utf8decoder = new TextDecoder('utf-8');\n\nfunction stringToUtf8(string) {\n  return utf8encoder.encode(string);\n}\n\nfunction utf8ToString(buffer) {\n  return utf8decoder.decode(buffer);\n}\n/**\n * Converts a string consisting of hexadecimal digits into an Uint8Array.\n */\n\n\nfunction hexStringToBytes(value) {\n  if (typeof value !== 'string') {\n    throw new TypeError('value is not a string');\n  }\n\n  if (!/^([0-9a-f][0-9a-f])*$/.test(value)) {\n    throw new RangeError('value is not hexadecimal');\n  }\n\n  if (value === '') {\n    return new Uint8Array(0);\n  } else {\n    return new Uint8Array(value.match(/../g).map(b => parseInt(b, 16)));\n  }\n}\n\nconst NIBBLE_TO_HEX = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\nconst BYTE_TO_HEX = new Array(256);\n\nfor (let i = 0; i < 256; i++) {\n  BYTE_TO_HEX[i] = `${NIBBLE_TO_HEX[i >>> 4 & 0xf]}${NIBBLE_TO_HEX[i & 0xf]}`;\n}\n/**\n * Converts a Uint8Array into the equivalent hexadecimal string.\n */\n\n\nfunction bytesToHexString(bytes) {\n  let hex = '',\n      len = bytes.byteLength;\n\n  for (let i = 0; i < len; i++) {\n    hex += BYTE_TO_HEX[bytes[i]];\n  }\n\n  return hex;\n}\n/**\n * Wrapper around an Uint8Array that allows values to be appended to the buffer,\n * and that automatically grows the buffer when space runs out.\n */\n\n\nclass Encoder {\n  constructor() {\n    this.buf = new Uint8Array(16);\n    this.offset = 0;\n  }\n  /**\n   * Returns the byte array containing the encoded data.\n   */\n\n\n  get buffer() {\n    this.finish();\n    return this.buf.subarray(0, this.offset);\n  }\n  /**\n   * Reallocates the encoder's buffer to be bigger.\n   */\n\n\n  grow(minSize = 0) {\n    let newSize = this.buf.byteLength * 4;\n\n    while (newSize < minSize) newSize *= 2;\n\n    const newBuf = new Uint8Array(newSize);\n    newBuf.set(this.buf, 0);\n    this.buf = newBuf;\n    return this;\n  }\n  /**\n   * Appends one byte (0 to 255) to the buffer.\n   */\n\n\n  appendByte(value) {\n    if (this.offset >= this.buf.byteLength) this.grow();\n    this.buf[this.offset] = value;\n    this.offset += 1;\n  }\n  /**\n   * Encodes a 32-bit nonnegative integer in a variable number of bytes using\n   * the LEB128 encoding scheme (https://en.wikipedia.org/wiki/LEB128) and\n   * appends it to the buffer. Returns the number of bytes written.\n   */\n\n\n  appendUint32(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer');\n    if (value < 0 || value > 0xffffffff) throw new RangeError('number out of range');\n    const numBytes = Math.max(1, Math.ceil((32 - Math.clz32(value)) / 7));\n    if (this.offset + numBytes > this.buf.byteLength) this.grow();\n\n    for (let i = 0; i < numBytes; i++) {\n      this.buf[this.offset + i] = value & 0x7f | (i === numBytes - 1 ? 0x00 : 0x80);\n      value >>>= 7; // zero-filling right shift\n    }\n\n    this.offset += numBytes;\n    return numBytes;\n  }\n  /**\n   * Encodes a 32-bit signed integer in a variable number of bytes using the\n   * LEB128 encoding scheme (https://en.wikipedia.org/wiki/LEB128) and appends\n   * it to the buffer. Returns the number of bytes written.\n   */\n\n\n  appendInt32(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer');\n    if (value < -0x80000000 || value > 0x7fffffff) throw new RangeError('number out of range');\n    const numBytes = Math.ceil((33 - Math.clz32(value >= 0 ? value : -value - 1)) / 7);\n    if (this.offset + numBytes > this.buf.byteLength) this.grow();\n\n    for (let i = 0; i < numBytes; i++) {\n      this.buf[this.offset + i] = value & 0x7f | (i === numBytes - 1 ? 0x00 : 0x80);\n      value >>= 7; // sign-propagating right shift\n    }\n\n    this.offset += numBytes;\n    return numBytes;\n  }\n  /**\n   * Encodes a nonnegative integer in a variable number of bytes using the LEB128\n   * encoding scheme, up to the maximum size of integers supported by JavaScript\n   * (53 bits).\n   */\n\n\n  appendUint53(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer');\n\n    if (value < 0 || value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError('number out of range');\n    }\n\n    const high32 = Math.floor(value / 0x100000000);\n    const low32 = (value & 0xffffffff) >>> 0; // right shift to interpret as unsigned\n\n    return this.appendUint64(high32, low32);\n  }\n  /**\n   * Encodes a signed integer in a variable number of bytes using the LEB128\n   * encoding scheme, up to the maximum size of integers supported by JavaScript\n   * (53 bits).\n   */\n\n\n  appendInt53(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer');\n\n    if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError('number out of range');\n    }\n\n    const high32 = Math.floor(value / 0x100000000);\n    const low32 = (value & 0xffffffff) >>> 0; // right shift to interpret as unsigned\n\n    return this.appendInt64(high32, low32);\n  }\n  /**\n   * Encodes a 64-bit nonnegative integer in a variable number of bytes using\n   * the LEB128 encoding scheme, and appends it to the buffer. The number is\n   * given as two 32-bit halves since JavaScript cannot accurately represent\n   * integers with more than 53 bits in a single variable.\n   */\n\n\n  appendUint64(high32, low32) {\n    if (!Number.isInteger(high32) || !Number.isInteger(low32)) {\n      throw new RangeError('value is not an integer');\n    }\n\n    if (high32 < 0 || high32 > 0xffffffff || low32 < 0 || low32 > 0xffffffff) {\n      throw new RangeError('number out of range');\n    }\n\n    if (high32 === 0) return this.appendUint32(low32);\n    const numBytes = Math.ceil((64 - Math.clz32(high32)) / 7);\n    if (this.offset + numBytes > this.buf.byteLength) this.grow();\n\n    for (let i = 0; i < 4; i++) {\n      this.buf[this.offset + i] = low32 & 0x7f | 0x80;\n      low32 >>>= 7; // zero-filling right shift\n    }\n\n    this.buf[this.offset + 4] = low32 & 0x0f | (high32 & 0x07) << 4 | (numBytes === 5 ? 0x00 : 0x80);\n    high32 >>>= 3;\n\n    for (let i = 5; i < numBytes; i++) {\n      this.buf[this.offset + i] = high32 & 0x7f | (i === numBytes - 1 ? 0x00 : 0x80);\n      high32 >>>= 7;\n    }\n\n    this.offset += numBytes;\n    return numBytes;\n  }\n  /**\n   * Encodes a 64-bit signed integer in a variable number of bytes using the\n   * LEB128 encoding scheme, and appends it to the buffer. The number is given\n   * as two 32-bit halves since JavaScript cannot accurately represent integers\n   * with more than 53 bits in a single variable. The sign of the 64-bit\n   * number is determined by the sign of the `high32` half; the sign of the\n   * `low32` half is ignored.\n   */\n\n\n  appendInt64(high32, low32) {\n    if (!Number.isInteger(high32) || !Number.isInteger(low32)) {\n      throw new RangeError('value is not an integer');\n    }\n\n    if (high32 < -0x80000000 || high32 > 0x7fffffff || low32 < -0x80000000 || low32 > 0xffffffff) {\n      throw new RangeError('number out of range');\n    }\n\n    low32 >>>= 0; // interpret as unsigned\n\n    if (high32 === 0 && low32 <= 0x7fffffff) return this.appendInt32(low32);\n    if (high32 === -1 && low32 >= 0x80000000) return this.appendInt32(low32 - 0x100000000);\n    const numBytes = Math.ceil((65 - Math.clz32(high32 >= 0 ? high32 : -high32 - 1)) / 7);\n    if (this.offset + numBytes > this.buf.byteLength) this.grow();\n\n    for (let i = 0; i < 4; i++) {\n      this.buf[this.offset + i] = low32 & 0x7f | 0x80;\n      low32 >>>= 7; // zero-filling right shift\n    }\n\n    this.buf[this.offset + 4] = low32 & 0x0f | (high32 & 0x07) << 4 | (numBytes === 5 ? 0x00 : 0x80);\n    high32 >>= 3; // sign-propagating right shift\n\n    for (let i = 5; i < numBytes; i++) {\n      this.buf[this.offset + i] = high32 & 0x7f | (i === numBytes - 1 ? 0x00 : 0x80);\n      high32 >>= 7;\n    }\n\n    this.offset += numBytes;\n    return numBytes;\n  }\n  /**\n   * Appends the contents of byte buffer `data` to the buffer. Returns the\n   * number of bytes appended.\n   */\n\n\n  appendRawBytes(data) {\n    if (this.offset + data.byteLength > this.buf.byteLength) {\n      this.grow(this.offset + data.byteLength);\n    }\n\n    this.buf.set(data, this.offset);\n    this.offset += data.byteLength;\n    return data.byteLength;\n  }\n  /**\n   * Appends a UTF-8 string to the buffer, without any metadata. Returns the\n   * number of bytes appended.\n   */\n\n\n  appendRawString(value) {\n    if (typeof value !== 'string') throw new TypeError('value is not a string');\n    return this.appendRawBytes(stringToUtf8(value));\n  }\n  /**\n   * Appends the contents of byte buffer `data` to the buffer, prefixed with the\n   * number of bytes in the buffer (as a LEB128-encoded unsigned integer).\n   */\n\n\n  appendPrefixedBytes(data) {\n    this.appendUint53(data.byteLength);\n    this.appendRawBytes(data);\n    return this;\n  }\n  /**\n   * Appends a UTF-8 string to the buffer, prefixed with its length in bytes\n   * (where the length is encoded as an unsigned LEB128 integer).\n   */\n\n\n  appendPrefixedString(value) {\n    if (typeof value !== 'string') throw new TypeError('value is not a string');\n    this.appendPrefixedBytes(stringToUtf8(value));\n    return this;\n  }\n  /**\n   * Takes a value, which must be a string consisting only of hexadecimal\n   * digits, maps it to a byte array, and appends it to the buffer, prefixed\n   * with its length in bytes.\n   */\n\n\n  appendHexString(value) {\n    this.appendPrefixedBytes(hexStringToBytes(value));\n    return this;\n  }\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n\n\n  finish() {}\n\n}\n/**\n * Counterpart to Encoder. Wraps a Uint8Array buffer with a cursor indicating\n * the current decoding position, and allows values to be incrementally read by\n * decoding the bytes at the current position.\n */\n\n\nclass Decoder {\n  constructor(buffer) {\n    if (!(buffer instanceof Uint8Array)) {\n      throw new TypeError(`Not a byte array: ${buffer}`);\n    }\n\n    this.buf = buffer;\n    this.offset = 0;\n  }\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n\n\n  get done() {\n    return this.offset === this.buf.byteLength;\n  }\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n\n\n  reset() {\n    this.offset = 0;\n  }\n  /**\n   * Moves the current decoding position forward by the specified number of\n   * bytes, without decoding anything.\n   */\n\n\n  skip(bytes) {\n    if (this.offset + bytes > this.buf.byteLength) {\n      throw new RangeError('cannot skip beyond end of buffer');\n    }\n\n    this.offset += bytes;\n  }\n  /**\n   * Reads one byte (0 to 255) from the buffer.\n   */\n\n\n  readByte() {\n    this.offset += 1;\n    return this.buf[this.offset - 1];\n  }\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the buffer.\n   * Throws an exception if the value doesn't fit in a 32-bit unsigned int.\n   */\n\n\n  readUint32() {\n    let result = 0,\n        shift = 0;\n\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset];\n\n      if (shift === 28 && (nextByte & 0xf0) !== 0) {\n        // more than 5 bytes, or value > 0xffffffff\n        throw new RangeError('number out of range');\n      }\n\n      result = (result | (nextByte & 0x7f) << shift) >>> 0; // right shift to interpret value as unsigned\n\n      shift += 7;\n      this.offset++;\n      if ((nextByte & 0x80) === 0) return result;\n    }\n\n    throw new RangeError('buffer ended with incomplete number');\n  }\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the buffer.\n   * Throws an exception if the value doesn't fit in a 32-bit signed int.\n   */\n\n\n  readInt32() {\n    let result = 0,\n        shift = 0;\n\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset];\n\n      if (shift === 28 && (nextByte & 0x80) !== 0 || // more than 5 bytes\n      shift === 28 && (nextByte & 0x40) === 0 && (nextByte & 0x38) !== 0 || // positive int > 0x7fffffff\n      shift === 28 && (nextByte & 0x40) !== 0 && (nextByte & 0x38) !== 0x38) {\n        // negative int < -0x80000000\n        throw new RangeError('number out of range');\n      }\n\n      result |= (nextByte & 0x7f) << shift;\n      shift += 7;\n      this.offset++;\n\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) === 0 || shift > 28) {\n          return result; // positive, or negative value that doesn't need sign-extending\n        } else {\n          return result | -1 << shift; // sign-extend negative integer\n        }\n      }\n    }\n\n    throw new RangeError('buffer ended with incomplete number');\n  }\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the\n   * buffer. Allows any integer that can be safely represented by JavaScript\n   * (up to 2^53 - 1), and throws an exception outside of that range.\n   */\n\n\n  readUint53() {\n    const {\n      low32,\n      high32\n    } = this.readUint64();\n\n    if (high32 < 0 || high32 > 0x1fffff) {\n      throw new RangeError('number out of range');\n    }\n\n    return high32 * 0x100000000 + low32;\n  }\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the\n   * buffer. Allows any integer that can be safely represented by JavaScript\n   * (between -(2^53 - 1) and 2^53 - 1), throws an exception outside of that range.\n   */\n\n\n  readInt53() {\n    const {\n      low32,\n      high32\n    } = this.readInt64();\n\n    if (high32 < -0x200000 || high32 === -0x200000 && low32 === 0 || high32 > 0x1fffff) {\n      throw new RangeError('number out of range');\n    }\n\n    return high32 * 0x100000000 + low32;\n  }\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the\n   * buffer. Throws an exception if the value doesn't fit in a 64-bit unsigned\n   * int. Returns the number in two 32-bit halves, as an object of the form\n   * `{high32, low32}`.\n   */\n\n\n  readUint64() {\n    let low32 = 0,\n        high32 = 0,\n        shift = 0;\n\n    while (this.offset < this.buf.byteLength && shift <= 28) {\n      const nextByte = this.buf[this.offset];\n      low32 = (low32 | (nextByte & 0x7f) << shift) >>> 0; // right shift to interpret value as unsigned\n\n      if (shift === 28) {\n        high32 = (nextByte & 0x70) >>> 4;\n      }\n\n      shift += 7;\n      this.offset++;\n      if ((nextByte & 0x80) === 0) return {\n        high32,\n        low32\n      };\n    }\n\n    shift = 3;\n\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset];\n\n      if (shift === 31 && (nextByte & 0xfe) !== 0) {\n        // more than 10 bytes, or value > 2^64 - 1\n        throw new RangeError('number out of range');\n      }\n\n      high32 = (high32 | (nextByte & 0x7f) << shift) >>> 0;\n      shift += 7;\n      this.offset++;\n      if ((nextByte & 0x80) === 0) return {\n        high32,\n        low32\n      };\n    }\n\n    throw new RangeError('buffer ended with incomplete number');\n  }\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the\n   * buffer. Throws an exception if the value doesn't fit in a 64-bit signed\n   * int. Returns the number in two 32-bit halves, as an object of the form\n   * `{high32, low32}`. The `low32` half is always non-negative, and the\n   * sign of the `high32` half indicates the sign of the 64-bit number.\n   */\n\n\n  readInt64() {\n    let low32 = 0,\n        high32 = 0,\n        shift = 0;\n\n    while (this.offset < this.buf.byteLength && shift <= 28) {\n      const nextByte = this.buf[this.offset];\n      low32 = (low32 | (nextByte & 0x7f) << shift) >>> 0; // right shift to interpret value as unsigned\n\n      if (shift === 28) {\n        high32 = (nextByte & 0x70) >>> 4;\n      }\n\n      shift += 7;\n      this.offset++;\n\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) !== 0) {\n          // sign-extend negative integer\n          if (shift < 32) low32 = (low32 | -1 << shift) >>> 0;\n          high32 |= -1 << Math.max(shift - 32, 0);\n        }\n\n        return {\n          high32,\n          low32\n        };\n      }\n    }\n\n    shift = 3;\n\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]; // On the 10th byte there are only two valid values: all 7 value bits zero\n      // (if the value is positive) or all 7 bits one (if the value is negative)\n\n      if (shift === 31 && nextByte !== 0 && nextByte !== 0x7f) {\n        throw new RangeError('number out of range');\n      }\n\n      high32 |= (nextByte & 0x7f) << shift;\n      shift += 7;\n      this.offset++;\n\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) !== 0 && shift < 32) {\n          // sign-extend negative integer\n          high32 |= -1 << shift;\n        }\n\n        return {\n          high32,\n          low32\n        };\n      }\n    }\n\n    throw new RangeError('buffer ended with incomplete number');\n  }\n  /**\n   * Extracts a subarray `length` bytes in size, starting from the current\n   * position in the buffer, and moves the position forward.\n   */\n\n\n  readRawBytes(length) {\n    const start = this.offset;\n\n    if (start + length > this.buf.byteLength) {\n      throw new RangeError('subarray exceeds buffer size');\n    }\n\n    this.offset += length;\n    return this.buf.subarray(start, this.offset);\n  }\n  /**\n   * Extracts `length` bytes from the buffer, starting from the current position,\n   * and returns the UTF-8 string decoding of those bytes.\n   */\n\n\n  readRawString(length) {\n    return utf8ToString(this.readRawBytes(length));\n  }\n  /**\n   * Extracts a subarray from the current position in the buffer, prefixed with\n   * its length in bytes (encoded as an unsigned LEB128 integer).\n   */\n\n\n  readPrefixedBytes() {\n    return this.readRawBytes(this.readUint53());\n  }\n  /**\n   * Reads a UTF-8 string from the current position in the buffer, prefixed with its\n   * length in bytes (where the length is encoded as an unsigned LEB128 integer).\n   */\n\n\n  readPrefixedString() {\n    return utf8ToString(this.readPrefixedBytes());\n  }\n  /**\n   * Reads a byte array from the current position in the buffer, prefixed with its\n   * length in bytes. Returns that byte array converted to a hexadecimal string.\n   */\n\n\n  readHexString() {\n    return bytesToHexString(this.readPrefixedBytes());\n  }\n\n}\n/**\n * An encoder that uses run-length encoding to compress sequences of repeated\n * values. The constructor argument specifies the type of values, which may be\n * either 'int', 'uint', or 'utf8'. Besides valid values of the selected\n * datatype, values may also be null.\n *\n * The encoded buffer starts with a LEB128-encoded signed integer, the\n * repetition count. The interpretation of the following values depends on this\n * repetition count:\n *   - If this number is a positive value n, the next value in the buffer\n *     (encoded as the specified datatype) is repeated n times in the sequence.\n *   - If the repetition count is a negative value -n, then the next n values\n *     (encoded as the specified datatype) in the buffer are treated as a\n *     literal, i.e. they appear in the sequence without any further\n *     interpretation or repetition.\n *   - If the repetition count is zero, then the next value in the buffer is a\n *     LEB128-encoded unsigned integer indicating the number of null values\n *     that appear at the current position in the sequence.\n *\n * After one of these three has completed, the process repeats, starting again\n * with a repetition count, until we reach the end of the buffer.\n */\n\n\nclass RLEEncoder extends Encoder {\n  constructor(type) {\n    super();\n    this.type = type;\n    this.state = 'empty';\n    this.lastValue = undefined;\n    this.count = 0;\n    this.literal = [];\n  }\n  /**\n   * Appends a new value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n\n\n  appendValue(value, repetitions = 1) {\n    this._appendValue(value, repetitions);\n  }\n  /**\n   * Like `appendValue()`, but this method is not overridden by `DeltaEncoder`.\n   */\n\n\n  _appendValue(value, repetitions = 1) {\n    if (repetitions <= 0) return;\n\n    if (this.state === 'empty') {\n      this.state = value === null ? 'nulls' : repetitions === 1 ? 'loneValue' : 'repetition';\n      this.lastValue = value;\n      this.count = repetitions;\n    } else if (this.state === 'loneValue') {\n      if (value === null) {\n        this.flush();\n        this.state = 'nulls';\n        this.count = repetitions;\n      } else if (value === this.lastValue) {\n        this.state = 'repetition';\n        this.count = 1 + repetitions;\n      } else if (repetitions > 1) {\n        this.flush();\n        this.state = 'repetition';\n        this.count = repetitions;\n        this.lastValue = value;\n      } else {\n        this.state = 'literal';\n        this.literal = [this.lastValue];\n        this.lastValue = value;\n      }\n    } else if (this.state === 'repetition') {\n      if (value === null) {\n        this.flush();\n        this.state = 'nulls';\n        this.count = repetitions;\n      } else if (value === this.lastValue) {\n        this.count += repetitions;\n      } else if (repetitions > 1) {\n        this.flush();\n        this.state = 'repetition';\n        this.count = repetitions;\n        this.lastValue = value;\n      } else {\n        this.flush();\n        this.state = 'loneValue';\n        this.lastValue = value;\n      }\n    } else if (this.state === 'literal') {\n      if (value === null) {\n        this.literal.push(this.lastValue);\n        this.flush();\n        this.state = 'nulls';\n        this.count = repetitions;\n      } else if (value === this.lastValue) {\n        this.flush();\n        this.state = 'repetition';\n        this.count = 1 + repetitions;\n      } else if (repetitions > 1) {\n        this.literal.push(this.lastValue);\n        this.flush();\n        this.state = 'repetition';\n        this.count = repetitions;\n        this.lastValue = value;\n      } else {\n        this.literal.push(this.lastValue);\n        this.lastValue = value;\n      }\n    } else if (this.state === 'nulls') {\n      if (value === null) {\n        this.count += repetitions;\n      } else if (repetitions > 1) {\n        this.flush();\n        this.state = 'repetition';\n        this.count = repetitions;\n        this.lastValue = value;\n      } else {\n        this.flush();\n        this.state = 'loneValue';\n        this.lastValue = value;\n      }\n    }\n  }\n  /**\n   * Copies values from the RLEDecoder `decoder` into this encoder. The `options` object may\n   * contain the following keys:\n   *  - `count`: The number of values to copy. If not specified, copies all remaining values.\n   *  - `sumValues`: If true, the function computes the sum of all numeric values as they are\n   *    copied (null values are counted as zero), and returns that number.\n   *  - `sumShift`: If set, values are shifted right by `sumShift` bits before adding to the sum.\n   *\n   * Returns an object of the form `{nonNullValues, sum}` where `nonNullValues` is the number of\n   * non-null values copied, and `sum` is the sum (only if the `sumValues` option is set).\n   */\n\n\n  copyFrom(decoder, options = {}) {\n    const {\n      count,\n      sumValues,\n      sumShift\n    } = options;\n\n    if (!(decoder instanceof RLEDecoder) || decoder.type !== this.type) {\n      throw new TypeError('incompatible type of decoder');\n    }\n\n    let remaining = typeof count === 'number' ? count : Number.MAX_SAFE_INTEGER;\n    let nonNullValues = 0,\n        sum = 0;\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);\n    if (remaining === 0 || decoder.done) return sumValues ? {\n      nonNullValues,\n      sum\n    } : {\n      nonNullValues\n    }; // Copy a value so that we have a well-defined starting state. NB: when super.copyFrom() is\n    // called by the DeltaEncoder subclass, the following calls to readValue() and appendValue()\n    // refer to the overridden methods, while later readRecord(), readRawValue() and _appendValue()\n    // calls refer to the non-overridden RLEDecoder/RLEEncoder methods.\n\n    let firstValue = decoder.readValue();\n\n    if (firstValue === null) {\n      const numNulls = Math.min(decoder.count + 1, remaining);\n      remaining -= numNulls;\n      decoder.count -= numNulls - 1;\n      this.appendValue(null, numNulls);\n      if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);\n      if (remaining === 0 || decoder.done) return sumValues ? {\n        nonNullValues,\n        sum\n      } : {\n        nonNullValues\n      };\n      firstValue = decoder.readValue();\n      if (firstValue === null) throw new RangeError('null run must be followed by non-null value');\n    }\n\n    this.appendValue(firstValue);\n    remaining--;\n    nonNullValues++;\n    if (sumValues) sum += sumShift ? firstValue >>> sumShift : firstValue;\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);\n    if (remaining === 0 || decoder.done) return sumValues ? {\n      nonNullValues,\n      sum\n    } : {\n      nonNullValues\n    }; // Copy data at the record level without expanding repetitions\n\n    let firstRun = decoder.count > 0;\n\n    while (remaining > 0 && !decoder.done) {\n      if (!firstRun) decoder.readRecord();\n      const numValues = Math.min(decoder.count, remaining);\n      decoder.count -= numValues;\n\n      if (decoder.state === 'literal') {\n        nonNullValues += numValues;\n\n        for (let i = 0; i < numValues; i++) {\n          if (decoder.done) throw new RangeError('incomplete literal');\n          const value = decoder.readRawValue();\n          if (value === decoder.lastValue) throw new RangeError('Repetition of values is not allowed in literal');\n          decoder.lastValue = value;\n\n          this._appendValue(value);\n\n          if (sumValues) sum += sumShift ? value >>> sumShift : value;\n        }\n      } else if (decoder.state === 'repetition') {\n        nonNullValues += numValues;\n        if (sumValues) sum += numValues * (sumShift ? decoder.lastValue >>> sumShift : decoder.lastValue);\n        const value = decoder.lastValue;\n\n        this._appendValue(value);\n\n        if (numValues > 1) {\n          this._appendValue(value);\n\n          if (this.state !== 'repetition') throw new RangeError(`Unexpected state ${this.state}`);\n          this.count += numValues - 2;\n        }\n      } else if (decoder.state === 'nulls') {\n        this._appendValue(null);\n\n        if (this.state !== 'nulls') throw new RangeError(`Unexpected state ${this.state}`);\n        this.count += numValues - 1;\n      }\n\n      firstRun = false;\n      remaining -= numValues;\n    }\n\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);\n    return sumValues ? {\n      nonNullValues,\n      sum\n    } : {\n      nonNullValues\n    };\n  }\n  /**\n   * Private method, do not call from outside the class.\n   */\n\n\n  flush() {\n    if (this.state === 'loneValue') {\n      this.appendInt32(-1);\n      this.appendRawValue(this.lastValue);\n    } else if (this.state === 'repetition') {\n      this.appendInt53(this.count);\n      this.appendRawValue(this.lastValue);\n    } else if (this.state === 'literal') {\n      this.appendInt53(-this.literal.length);\n\n      for (let v of this.literal) this.appendRawValue(v);\n    } else if (this.state === 'nulls') {\n      this.appendInt32(0);\n      this.appendUint53(this.count);\n    }\n\n    this.state = 'empty';\n  }\n  /**\n   * Private method, do not call from outside the class.\n   */\n\n\n  appendRawValue(value) {\n    if (this.type === 'int') {\n      this.appendInt53(value);\n    } else if (this.type === 'uint') {\n      this.appendUint53(value);\n    } else if (this.type === 'utf8') {\n      this.appendPrefixedString(value);\n    } else {\n      throw new RangeError(`Unknown RLEEncoder datatype: ${this.type}`);\n    }\n  }\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n\n\n  finish() {\n    if (this.state === 'literal') this.literal.push(this.lastValue); // Don't write anything if the only values we have seen are nulls\n\n    if (this.state !== 'nulls' || this.offset > 0) this.flush();\n  }\n\n}\n/**\n * Counterpart to RLEEncoder: reads values from an RLE-compressed sequence,\n * returning nulls and repeated values as required.\n */\n\n\nclass RLEDecoder extends Decoder {\n  constructor(type, buffer) {\n    super(buffer);\n    this.type = type;\n    this.lastValue = undefined;\n    this.count = 0;\n    this.state = undefined;\n  }\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n\n\n  get done() {\n    return this.count === 0 && this.offset === this.buf.byteLength;\n  }\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n\n\n  reset() {\n    this.offset = 0;\n    this.lastValue = undefined;\n    this.count = 0;\n    this.state = undefined;\n  }\n  /**\n   * Returns the next value (or null) in the sequence.\n   */\n\n\n  readValue() {\n    if (this.done) return null;\n    if (this.count === 0) this.readRecord();\n    this.count -= 1;\n\n    if (this.state === 'literal') {\n      const value = this.readRawValue();\n      if (value === this.lastValue) throw new RangeError('Repetition of values is not allowed in literal');\n      this.lastValue = value;\n      return value;\n    } else {\n      return this.lastValue;\n    }\n  }\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n\n\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) {\n        this.count = this.readInt53();\n\n        if (this.count > 0) {\n          this.lastValue = this.count <= numSkip ? this.skipRawValues(1) : this.readRawValue();\n          this.state = 'repetition';\n        } else if (this.count < 0) {\n          this.count = -this.count;\n          this.state = 'literal';\n        } else {\n          // this.count == 0\n          this.count = this.readUint53();\n          this.lastValue = null;\n          this.state = 'nulls';\n        }\n      }\n\n      const consume = Math.min(numSkip, this.count);\n      if (this.state === 'literal') this.skipRawValues(consume);\n      numSkip -= consume;\n      this.count -= consume;\n    }\n  }\n  /**\n   * Private method, do not call from outside the class.\n   * Reads a repetition count from the buffer and sets up the state appropriately.\n   */\n\n\n  readRecord() {\n    this.count = this.readInt53();\n\n    if (this.count > 1) {\n      const value = this.readRawValue();\n\n      if ((this.state === 'repetition' || this.state === 'literal') && this.lastValue === value) {\n        throw new RangeError('Successive repetitions with the same value are not allowed');\n      }\n\n      this.state = 'repetition';\n      this.lastValue = value;\n    } else if (this.count === 1) {\n      throw new RangeError('Repetition count of 1 is not allowed, use a literal instead');\n    } else if (this.count < 0) {\n      this.count = -this.count;\n      if (this.state === 'literal') throw new RangeError('Successive literals are not allowed');\n      this.state = 'literal';\n    } else {\n      // this.count == 0\n      if (this.state === 'nulls') throw new RangeError('Successive null runs are not allowed');\n      this.count = this.readUint53();\n      if (this.count === 0) throw new RangeError('Zero-length null runs are not allowed');\n      this.lastValue = null;\n      this.state = 'nulls';\n    }\n  }\n  /**\n   * Private method, do not call from outside the class.\n   * Reads one value of the datatype configured on construction.\n   */\n\n\n  readRawValue() {\n    if (this.type === 'int') {\n      return this.readInt53();\n    } else if (this.type === 'uint') {\n      return this.readUint53();\n    } else if (this.type === 'utf8') {\n      return this.readPrefixedString();\n    } else {\n      throw new RangeError(`Unknown RLEDecoder datatype: ${this.type}`);\n    }\n  }\n  /**\n   * Private method, do not call from outside the class.\n   * Skips over `num` values of the datatype configured on construction.\n   */\n\n\n  skipRawValues(num) {\n    if (this.type === 'utf8') {\n      for (let i = 0; i < num; i++) this.skip(this.readUint53());\n    } else {\n      while (num > 0 && this.offset < this.buf.byteLength) {\n        if ((this.buf[this.offset] & 0x80) === 0) num--;\n        this.offset++;\n      }\n\n      if (num > 0) throw new RangeError('cannot skip beyond end of buffer');\n    }\n  }\n\n}\n/**\n * A variant of RLEEncoder: rather than storing the actual values passed to\n * appendValue(), this version stores only the first value, and for all\n * subsequent values it stores the difference to the previous value. This\n * encoding is good when values tend to come in sequentially incrementing runs,\n * because the delta between successive values is 1, and repeated values of 1\n * are easily compressed with run-length encoding.\n *\n * Null values are also allowed, as with RLEEncoder.\n */\n\n\nclass DeltaEncoder extends RLEEncoder {\n  constructor() {\n    super('int');\n    this.absoluteValue = 0;\n  }\n  /**\n   * Appends a new integer value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n\n\n  appendValue(value, repetitions = 1) {\n    if (repetitions <= 0) return;\n\n    if (typeof value === 'number') {\n      super.appendValue(value - this.absoluteValue, 1);\n      this.absoluteValue = value;\n      if (repetitions > 1) super.appendValue(0, repetitions - 1);\n    } else {\n      super.appendValue(value, repetitions);\n    }\n  }\n  /**\n   * Copies values from the DeltaDecoder `decoder` into this encoder. The `options` object may\n   * contain the key `count`, indicating the number of values to copy. If not specified, copies\n   * all remaining values in the decoder.\n   */\n\n\n  copyFrom(decoder, options = {}) {\n    if (options.sumValues) {\n      throw new RangeError('unsupported options for DeltaEncoder.copyFrom()');\n    }\n\n    if (!(decoder instanceof DeltaDecoder)) {\n      throw new TypeError('incompatible type of decoder');\n    }\n\n    let remaining = options.count;\n    if (remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${remaining} values`);\n    if (remaining === 0 || decoder.done) return; // Copy any null values, and the first non-null value, so that appendValue() computes the\n    // difference between the encoder's last value and the decoder's first (absolute) value.\n\n    let value = decoder.readValue(),\n        nulls = 0;\n    this.appendValue(value);\n\n    if (value === null) {\n      nulls = decoder.count + 1;\n      if (remaining !== undefined && remaining < nulls) nulls = remaining;\n      decoder.count -= nulls - 1;\n      this.count += nulls - 1;\n      if (remaining > nulls && decoder.done) throw new RangeError(`cannot copy ${remaining} values`);\n      if (remaining === nulls || decoder.done) return; // The next value read is certain to be non-null because we're not at the end of the decoder,\n      // and a run of nulls must be followed by a run of non-nulls.\n\n      if (decoder.count === 0) this.appendValue(decoder.readValue());\n    } // Once we have the first value, the subsequent relative values can be copied verbatim without\n    // any further processing. Note that the first value copied by super.copyFrom() is an absolute\n    // value, while subsequent values are relative. Thus, the sum of all of the (non-null) copied\n    // values must equal the absolute value of the final element copied.\n\n\n    if (remaining !== undefined) remaining -= nulls + 1;\n    const {\n      nonNullValues,\n      sum\n    } = super.copyFrom(decoder, {\n      count: remaining,\n      sumValues: true\n    });\n\n    if (nonNullValues > 0) {\n      this.absoluteValue = sum;\n      decoder.absoluteValue = sum;\n    }\n  }\n\n}\n/**\n * Counterpart to DeltaEncoder: reads values from a delta-compressed sequence of\n * numbers (may include null values).\n */\n\n\nclass DeltaDecoder extends RLEDecoder {\n  constructor(buffer) {\n    super('int', buffer);\n    this.absoluteValue = 0;\n  }\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n\n\n  reset() {\n    this.offset = 0;\n    this.lastValue = undefined;\n    this.count = 0;\n    this.state = undefined;\n    this.absoluteValue = 0;\n  }\n  /**\n   * Returns the next integer (or null) value in the sequence.\n   */\n\n\n  readValue() {\n    const value = super.readValue();\n    if (value === null) return null;\n    this.absoluteValue += value;\n    return this.absoluteValue;\n  }\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n\n\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) this.readRecord();\n      const consume = Math.min(numSkip, this.count);\n\n      if (this.state === 'literal') {\n        for (let i = 0; i < consume; i++) {\n          this.lastValue = this.readRawValue();\n          this.absoluteValue += this.lastValue;\n        }\n      } else if (this.state === 'repetition') {\n        this.absoluteValue += consume * this.lastValue;\n      }\n\n      numSkip -= consume;\n      this.count -= consume;\n    }\n  }\n\n}\n/**\n * Encodes a sequence of boolean values by mapping it to a sequence of integers:\n * the number of false values, followed by the number of true values, followed\n * by the number of false values, and so on. Each number is encoded as a LEB128\n * unsigned integer. This encoding is a bit like RLEEncoder, except that we\n * only encode the repetition count but not the actual value, since the values\n * just alternate between false and true (starting with false).\n */\n\n\nclass BooleanEncoder extends Encoder {\n  constructor() {\n    super();\n    this.lastValue = false;\n    this.count = 0;\n  }\n  /**\n   * Appends a new value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n\n\n  appendValue(value, repetitions = 1) {\n    if (value !== false && value !== true) {\n      throw new RangeError(`Unsupported value for BooleanEncoder: ${value}`);\n    }\n\n    if (repetitions <= 0) return;\n\n    if (this.lastValue === value) {\n      this.count += repetitions;\n    } else {\n      this.appendUint53(this.count);\n      this.lastValue = value;\n      this.count = repetitions;\n    }\n  }\n  /**\n   * Copies values from the BooleanDecoder `decoder` into this encoder. The `options` object may\n   * contain the key `count`, indicating the number of values to copy. If not specified, copies\n   * all remaining values in the decoder.\n   */\n\n\n  copyFrom(decoder, options = {}) {\n    if (!(decoder instanceof BooleanDecoder)) {\n      throw new TypeError('incompatible type of decoder');\n    }\n\n    const {\n      count\n    } = options;\n    let remaining = typeof count === 'number' ? count : Number.MAX_SAFE_INTEGER;\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);\n    if (remaining === 0 || decoder.done) return; // Copy one value to bring decoder and encoder state into sync, then finish that value's repetitions\n\n    this.appendValue(decoder.readValue());\n    remaining--;\n    const firstCopy = Math.min(decoder.count, remaining);\n    this.count += firstCopy;\n    decoder.count -= firstCopy;\n    remaining -= firstCopy;\n\n    while (remaining > 0 && !decoder.done) {\n      decoder.count = decoder.readUint53();\n      if (decoder.count === 0) throw new RangeError('Zero-length runs are not allowed');\n      decoder.lastValue = !decoder.lastValue;\n      this.appendUint53(this.count);\n      const numCopied = Math.min(decoder.count, remaining);\n      this.count = numCopied;\n      this.lastValue = decoder.lastValue;\n      decoder.count -= numCopied;\n      remaining -= numCopied;\n    }\n\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);\n  }\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n\n\n  finish() {\n    if (this.count > 0) {\n      this.appendUint53(this.count);\n      this.count = 0;\n    }\n  }\n\n}\n/**\n * Counterpart to BooleanEncoder: reads boolean values from a runlength-encoded\n * sequence.\n */\n\n\nclass BooleanDecoder extends Decoder {\n  constructor(buffer) {\n    super(buffer);\n    this.lastValue = true; // is negated the first time we read a count\n\n    this.firstRun = true;\n    this.count = 0;\n  }\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n\n\n  get done() {\n    return this.count === 0 && this.offset === this.buf.byteLength;\n  }\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n\n\n  reset() {\n    this.offset = 0;\n    this.lastValue = true;\n    this.firstRun = true;\n    this.count = 0;\n  }\n  /**\n   * Returns the next value in the sequence.\n   */\n\n\n  readValue() {\n    if (this.done) return false;\n\n    while (this.count === 0) {\n      this.count = this.readUint53();\n      this.lastValue = !this.lastValue;\n\n      if (this.count === 0 && !this.firstRun) {\n        throw new RangeError('Zero-length runs are not allowed');\n      }\n\n      this.firstRun = false;\n    }\n\n    this.count -= 1;\n    return this.lastValue;\n  }\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n\n\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) {\n        this.count = this.readUint53();\n        this.lastValue = !this.lastValue;\n\n        if (this.count === 0 && !this.firstRun) {\n          throw new RangeError('Zero-length runs are not allowed');\n        }\n\n        this.firstRun = false;\n      }\n\n      if (this.count < numSkip) {\n        numSkip -= this.count;\n        this.count = 0;\n      } else {\n        this.count -= numSkip;\n        numSkip = 0;\n      }\n    }\n  }\n\n}\n\nmodule.exports = {\n  stringToUtf8,\n  utf8ToString,\n  hexStringToBytes,\n  bytesToHexString,\n  Encoder,\n  Decoder,\n  RLEEncoder,\n  RLEDecoder,\n  DeltaEncoder,\n  DeltaDecoder,\n  BooleanEncoder,\n  BooleanDecoder\n};","map":null,"metadata":{},"sourceType":"script"}