{"ast":null,"code":"const {\n  OBJECT_ID,\n  CONFLICTS\n} = require('./constants');\n\nconst {\n  isObject,\n  copyObject\n} = require('../src/common');\n\nfunction compareRows(properties, row1, row2) {\n  for (let prop of properties) {\n    if (row1[prop] === row2[prop]) continue;\n\n    if (typeof row1[prop] === 'number' && typeof row2[prop] === 'number') {\n      return row1[prop] - row2[prop];\n    } else {\n      const prop1 = '' + row1[prop],\n            prop2 = '' + row2[prop];\n      if (prop1 === prop2) continue;\n      if (prop1 < prop2) return -1;else return +1;\n    }\n  }\n\n  return 0;\n}\n/**\n * A relational-style unordered collection of records (rows). Each row is an\n * object that maps column names to values. The set of rows is represented by\n * a map from UUID to row object.\n */\n\n\nclass Table {\n  /**\n   * This constructor is used by application code when creating a new Table\n   * object within a change callback.\n   */\n  constructor() {\n    this.entries = Object.freeze({});\n    this.opIds = Object.freeze({});\n    Object.freeze(this);\n  }\n  /**\n   * Looks up a row in the table by its unique ID.\n   */\n\n\n  byId(id) {\n    return this.entries[id];\n  }\n  /**\n   * Returns an array containing the unique IDs of all rows in the table, in no\n   * particular order.\n   */\n\n\n  get ids() {\n    return Object.keys(this.entries).filter(key => {\n      const entry = this.entries[key];\n      return isObject(entry) && entry.id === key;\n    });\n  }\n  /**\n   * Returns the number of rows in the table.\n   */\n\n\n  get count() {\n    return this.ids.length;\n  }\n  /**\n   * Returns an array containing all of the rows in the table, in no particular\n   * order.\n   */\n\n\n  get rows() {\n    return this.ids.map(id => this.byId(id));\n  }\n  /**\n   * The standard JavaScript `filter()` method, which passes each row to the\n   * callback function and returns all rows for which the it returns true.\n   */\n\n\n  filter(callback, thisArg) {\n    return this.rows.filter(callback, thisArg);\n  }\n  /**\n   * The standard JavaScript `find()` method, which passes each row to the\n   * callback function and returns the first row for which it returns true.\n   */\n\n\n  find(callback, thisArg) {\n    return this.rows.find(callback, thisArg);\n  }\n  /**\n   * The standard JavaScript `map()` method, which passes each row to the\n   * callback function and returns a list of its return values.\n   */\n\n\n  map(callback, thisArg) {\n    return this.rows.map(callback, thisArg);\n  }\n  /**\n  * Returns the list of rows, sorted by one of the following:\n  * - If a function argument is given, it compares rows as per\n  *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description\n  * - If a string argument is given, it is interpreted as a column name and\n  *   rows are sorted according to that column.\n  * - If an array of strings is given, it is interpreted as a list of column\n  *   names, and rows are sorted lexicographically by those columns.\n  * - If no argument is given, it sorts by row ID by default.\n  */\n\n\n  sort(arg) {\n    if (typeof arg === 'function') {\n      return this.rows.sort(arg);\n    } else if (typeof arg === 'string') {\n      return this.rows.sort((row1, row2) => compareRows([arg], row1, row2));\n    } else if (Array.isArray(arg)) {\n      return this.rows.sort((row1, row2) => compareRows(arg, row1, row2));\n    } else if (arg === undefined) {\n      return this.rows.sort((row1, row2) => compareRows(['id'], row1, row2));\n    } else {\n      throw new TypeError(`Unsupported sorting argument: ${arg}`);\n    }\n  }\n  /**\n   * When iterating over a table, you get all rows in the table, in no\n   * particular order.\n   */\n\n\n  [Symbol.iterator]() {\n    let rows = this.rows,\n        index = -1;\n    return {\n      next() {\n        index += 1;\n\n        if (index < rows.length) {\n          return {\n            done: false,\n            value: rows[index]\n          };\n        } else {\n          return {\n            done: true\n          };\n        }\n      }\n\n    };\n  }\n  /**\n   * Returns a shallow clone of this object. This clone is used while applying\n   * a patch to the table, and `freeze()` is called on it when we have finished\n   * applying the patch.\n   */\n\n\n  _clone() {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('clone() requires the objectId to be set');\n    }\n\n    return instantiateTable(this[OBJECT_ID], copyObject(this.entries), copyObject(this.opIds));\n  }\n  /**\n   * Sets the entry with key `id` to `value`. `opId` is the ID of the operation\n   * performing this assignment. This method is for internal use only; it is\n   * not part of the public API of Automerge.Table.\n   */\n\n\n  _set(id, value, opId) {\n    if (Object.isFrozen(this.entries)) {\n      throw new Error('A table can only be modified in a change function');\n    }\n\n    if (isObject(value) && !Array.isArray(value)) {\n      Object.defineProperty(value, 'id', {\n        value: id,\n        enumerable: true\n      });\n    }\n\n    this.entries[id] = value;\n    this.opIds[id] = opId;\n  }\n  /**\n   * Removes the row with unique ID `id` from the table.\n   */\n\n\n  remove(id) {\n    if (Object.isFrozen(this.entries)) {\n      throw new Error('A table can only be modified in a change function');\n    }\n\n    delete this.entries[id];\n    delete this.opIds[id];\n  }\n  /**\n   * Makes this object immutable. This is called after a change has been made.\n   */\n\n\n  _freeze() {\n    Object.freeze(this.entries);\n    Object.freeze(this.opIds);\n    Object.freeze(this);\n  }\n  /**\n   * Returns a writeable instance of this table. This instance is returned when\n   * the table is accessed within a change callback. `context` is the proxy\n   * context that keeps track of the mutations.\n   */\n\n\n  getWriteable(context, path) {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('getWriteable() requires the objectId to be set');\n    }\n\n    const instance = Object.create(WriteableTable.prototype);\n    instance[OBJECT_ID] = this[OBJECT_ID];\n    instance.context = context;\n    instance.entries = this.entries;\n    instance.opIds = this.opIds;\n    instance.path = path;\n    return instance;\n  }\n  /**\n   * Returns an object containing the table entries, indexed by objectID,\n   * for serializing an Automerge document to JSON.\n   */\n\n\n  toJSON() {\n    const rows = {};\n\n    for (let id of this.ids) rows[id] = this.byId(id);\n\n    return rows;\n  }\n\n}\n/**\n * An instance of this class is used when a table is accessed within a change\n * callback.\n */\n\n\nclass WriteableTable extends Table {\n  /**\n   * Returns a proxied version of the row with ID `id`. This row object can be\n   * modified within a change callback.\n   */\n  byId(id) {\n    if (isObject(this.entries[id]) && this.entries[id].id === id) {\n      const objectId = this.entries[id][OBJECT_ID];\n      const path = this.path.concat([{\n        key: id,\n        objectId\n      }]);\n      return this.context.instantiateObject(path, objectId, ['id']);\n    }\n  }\n  /**\n   * Adds a new row to the table. The row is given as a map from\n   * column name to value. Returns the objectId of the new row.\n   */\n\n\n  add(row) {\n    return this.context.addTableRow(this.path, row);\n  }\n  /**\n   * Removes the row with ID `id` from the table. Throws an exception if the row\n   * does not exist in the table.\n   */\n\n\n  remove(id) {\n    if (isObject(this.entries[id]) && this.entries[id].id === id) {\n      this.context.deleteTableRow(this.path, id, this.opIds[id]);\n    } else {\n      throw new RangeError(`There is no row with ID ${id} in this table`);\n    }\n  }\n\n}\n/**\n * This function is used to instantiate a Table object in the context of\n * applying a patch (see apply_patch.js).\n */\n\n\nfunction instantiateTable(objectId, entries, opIds) {\n  const instance = Object.create(Table.prototype);\n\n  if (!objectId) {\n    throw new RangeError('instantiateTable requires an objectId to be given');\n  }\n\n  instance[OBJECT_ID] = objectId;\n  instance[CONFLICTS] = Object.freeze({});\n  instance.entries = entries || {};\n  instance.opIds = opIds || {};\n  return instance;\n}\n\nmodule.exports = {\n  Table,\n  instantiateTable\n};","map":null,"metadata":{},"sourceType":"script"}