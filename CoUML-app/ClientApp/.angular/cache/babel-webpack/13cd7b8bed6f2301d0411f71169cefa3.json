{"ast":null,"code":"const {\n  isObject,\n  copyObject,\n  parseOpId\n} = require('../src/common');\n\nconst {\n  OBJECT_ID,\n  CONFLICTS,\n  ELEM_IDS\n} = require('./constants');\n\nconst {\n  instantiateText\n} = require('./text');\n\nconst {\n  instantiateTable\n} = require('./table');\n\nconst {\n  Counter\n} = require('./counter');\n/**\n * Reconstructs the value from the patch object `patch`.\n */\n\n\nfunction getValue(patch, object, updated) {\n  if (patch.objectId) {\n    // If the objectId of the existing object does not match the objectId in the patch,\n    // that means the patch is replacing the object with a new one made from scratch\n    if (object && object[OBJECT_ID] !== patch.objectId) {\n      object = undefined;\n    }\n\n    return interpretPatch(patch, object, updated);\n  } else if (patch.datatype === 'timestamp') {\n    // Timestamp: value is milliseconds since 1970 epoch\n    return new Date(patch.value);\n  } else if (patch.datatype === 'counter') {\n    return new Counter(patch.value);\n  } else {\n    // Primitive value (int, uint, float64, string, boolean, or null)\n    return patch.value;\n  }\n}\n/**\n * Compares two strings, interpreted as Lamport timestamps of the form\n * 'counter@actorId'. Returns 1 if ts1 is greater, or -1 if ts2 is greater.\n */\n\n\nfunction lamportCompare(ts1, ts2) {\n  const regex = /^(\\d+)@(.*)$/;\n  const time1 = regex.test(ts1) ? parseOpId(ts1) : {\n    counter: 0,\n    actorId: ts1\n  };\n  const time2 = regex.test(ts2) ? parseOpId(ts2) : {\n    counter: 0,\n    actorId: ts2\n  };\n  if (time1.counter < time2.counter) return -1;\n  if (time1.counter > time2.counter) return 1;\n  if (time1.actorId < time2.actorId) return -1;\n  if (time1.actorId > time2.actorId) return 1;\n  return 0;\n}\n/**\n * `props` is an object of the form:\n * `{key1: {opId1: {...}, opId2: {...}}, key2: {opId3: {...}}}`\n * where the outer object is a mapping from property names to inner objects,\n * and the inner objects are a mapping from operation ID to sub-patch.\n * This function interprets that structure and updates the objects `object` and\n * `conflicts` to reflect it. For each key, the greatest opId (by Lamport TS\n * order) is chosen as the default resolution; that op's value is assigned\n * to `object[key]`. Moreover, all the opIds and values are packed into a\n * conflicts object of the form `{opId1: value1, opId2: value2}` and assigned\n * to `conflicts[key]`. If there is no conflict, the conflicts object contains\n * just a single opId-value mapping.\n */\n\n\nfunction applyProperties(props, object, conflicts, updated) {\n  if (!props) return;\n\n  for (let key of Object.keys(props)) {\n    const values = {},\n          opIds = Object.keys(props[key]).sort(lamportCompare).reverse();\n\n    for (let opId of opIds) {\n      const subpatch = props[key][opId];\n\n      if (conflicts[key] && conflicts[key][opId]) {\n        values[opId] = getValue(subpatch, conflicts[key][opId], updated);\n      } else {\n        values[opId] = getValue(subpatch, undefined, updated);\n      }\n    }\n\n    if (opIds.length === 0) {\n      delete object[key];\n      delete conflicts[key];\n    } else {\n      object[key] = values[opIds[0]];\n      conflicts[key] = values;\n    }\n  }\n}\n/**\n * Creates a writable copy of an immutable map object. If `originalObject`\n * is undefined, creates an empty object with ID `objectId`.\n */\n\n\nfunction cloneMapObject(originalObject, objectId) {\n  const object = copyObject(originalObject);\n  const conflicts = copyObject(originalObject ? originalObject[CONFLICTS] : undefined);\n  Object.defineProperty(object, OBJECT_ID, {\n    value: objectId\n  });\n  Object.defineProperty(object, CONFLICTS, {\n    value: conflicts\n  });\n  return object;\n}\n/**\n * Updates the map object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\n\n\nfunction updateMapObject(patch, obj, updated) {\n  const objectId = patch.objectId;\n\n  if (!updated[objectId]) {\n    updated[objectId] = cloneMapObject(obj, objectId);\n  }\n\n  const object = updated[objectId];\n  applyProperties(patch.props, object, object[CONFLICTS], updated);\n  return object;\n}\n/**\n * Updates the table object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\n\n\nfunction updateTableObject(patch, obj, updated) {\n  const objectId = patch.objectId;\n\n  if (!updated[objectId]) {\n    updated[objectId] = obj ? obj._clone() : instantiateTable(objectId);\n  }\n\n  const object = updated[objectId];\n\n  for (let key of Object.keys(patch.props || {})) {\n    const opIds = Object.keys(patch.props[key]);\n\n    if (opIds.length === 0) {\n      object.remove(key);\n    } else if (opIds.length === 1) {\n      const subpatch = patch.props[key][opIds[0]];\n\n      object._set(key, getValue(subpatch, object.byId(key), updated), opIds[0]);\n    } else {\n      throw new RangeError('Conflicts are not supported on properties of a table');\n    }\n  }\n\n  return object;\n}\n/**\n * Creates a writable copy of an immutable list object. If `originalList` is\n * undefined, creates an empty list with ID `objectId`.\n */\n\n\nfunction cloneListObject(originalList, objectId) {\n  const list = originalList ? originalList.slice() : []; // slice() makes a shallow clone\n\n  const conflicts = originalList && originalList[CONFLICTS] ? originalList[CONFLICTS].slice() : [];\n  const elemIds = originalList && originalList[ELEM_IDS] ? originalList[ELEM_IDS].slice() : [];\n  Object.defineProperty(list, OBJECT_ID, {\n    value: objectId\n  });\n  Object.defineProperty(list, CONFLICTS, {\n    value: conflicts\n  });\n  Object.defineProperty(list, ELEM_IDS, {\n    value: elemIds\n  });\n  return list;\n}\n/**\n * Updates the list object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\n\n\nfunction updateListObject(patch, obj, updated) {\n  const objectId = patch.objectId;\n\n  if (!updated[objectId]) {\n    updated[objectId] = cloneListObject(obj, objectId);\n  }\n\n  const list = updated[objectId],\n        conflicts = list[CONFLICTS],\n        elemIds = list[ELEM_IDS];\n\n  for (let i = 0; i < patch.edits.length; i++) {\n    const edit = patch.edits[i];\n\n    if (edit.action === 'insert' || edit.action === 'update') {\n      const oldValue = conflicts[edit.index] && conflicts[edit.index][edit.opId];\n      let lastValue = getValue(edit.value, oldValue, updated);\n      let values = {\n        [edit.opId]: lastValue\n      }; // Successive updates for the same index are an indication of a conflict on that list element.\n      // Edits are sorted in increasing order by Lamport timestamp, so the last value (with the\n      // greatest timestamp) is the default resolution of the conflict.\n\n      while (i < patch.edits.length - 1 && patch.edits[i + 1].index === edit.index && patch.edits[i + 1].action === 'update') {\n        i++;\n        const conflict = patch.edits[i];\n        const oldValue2 = conflicts[conflict.index] && conflicts[conflict.index][conflict.opId];\n        lastValue = getValue(conflict.value, oldValue2, updated);\n        values[conflict.opId] = lastValue;\n      }\n\n      if (edit.action === 'insert') {\n        list.splice(edit.index, 0, lastValue);\n        conflicts.splice(edit.index, 0, values);\n        elemIds.splice(edit.index, 0, edit.elemId);\n      } else {\n        list[edit.index] = lastValue;\n        conflicts[edit.index] = values;\n      }\n    } else if (edit.action === 'multi-insert') {\n      const startElemId = parseOpId(edit.elemId),\n            newElems = [],\n            newValues = [],\n            newConflicts = [];\n      const datatype = edit.datatype;\n      edit.values.forEach((value, index) => {\n        const elemId = `${startElemId.counter + index}@${startElemId.actorId}`;\n        value = getValue({\n          value,\n          datatype\n        }, undefined, updated);\n        newValues.push(value);\n        newConflicts.push({\n          [elemId]: {\n            value,\n            datatype,\n            type: 'value'\n          }\n        });\n        newElems.push(elemId);\n      });\n      list.splice(edit.index, 0, ...newValues);\n      conflicts.splice(edit.index, 0, ...newConflicts);\n      elemIds.splice(edit.index, 0, ...newElems);\n    } else if (edit.action === 'remove') {\n      list.splice(edit.index, edit.count);\n      conflicts.splice(edit.index, edit.count);\n      elemIds.splice(edit.index, edit.count);\n    }\n  }\n\n  return list;\n}\n/**\n * Updates the text object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\n\n\nfunction updateTextObject(patch, obj, updated) {\n  const objectId = patch.objectId;\n  let elems;\n\n  if (updated[objectId]) {\n    elems = updated[objectId].elems;\n  } else if (obj) {\n    elems = obj.elems.slice();\n  } else {\n    elems = [];\n  }\n\n  for (const edit of patch.edits) {\n    if (edit.action === 'insert') {\n      const value = getValue(edit.value, undefined, updated);\n      const elem = {\n        elemId: edit.elemId,\n        pred: [edit.opId],\n        value\n      };\n      elems.splice(edit.index, 0, elem);\n    } else if (edit.action === 'multi-insert') {\n      const startElemId = parseOpId(edit.elemId);\n      const datatype = edit.datatype;\n      const newElems = edit.values.map((value, index) => {\n        value = getValue({\n          datatype,\n          value\n        }, undefined, updated);\n        const elemId = `${startElemId.counter + index}@${startElemId.actorId}`;\n        return {\n          elemId,\n          pred: [elemId],\n          value\n        };\n      });\n      elems.splice(edit.index, 0, ...newElems);\n    } else if (edit.action === 'update') {\n      const elemId = elems[edit.index].elemId;\n      const value = getValue(edit.value, elems[edit.index].value, updated);\n      elems[edit.index] = {\n        elemId,\n        pred: [edit.opId],\n        value\n      };\n    } else if (edit.action === 'remove') {\n      elems.splice(edit.index, edit.count);\n    }\n  }\n\n  updated[objectId] = instantiateText(objectId, elems);\n  return updated[objectId];\n}\n/**\n * Applies the patch object `patch` to the read-only document object `obj`.\n * Clones a writable copy of `obj` and places it in `updated` (indexed by\n * objectId), if that has not already been done. Returns the updated object.\n */\n\n\nfunction interpretPatch(patch, obj, updated) {\n  // Return original object if it already exists and isn't being modified\n  if (isObject(obj) && (!patch.props || Object.keys(patch.props).length === 0) && (!patch.edits || patch.edits.length === 0) && !updated[patch.objectId]) {\n    return obj;\n  }\n\n  if (patch.type === 'map') {\n    return updateMapObject(patch, obj, updated);\n  } else if (patch.type === 'table') {\n    return updateTableObject(patch, obj, updated);\n  } else if (patch.type === 'list') {\n    return updateListObject(patch, obj, updated);\n  } else if (patch.type === 'text') {\n    return updateTextObject(patch, obj, updated);\n  } else {\n    throw new TypeError(`Unknown object type: ${patch.type}`);\n  }\n}\n/**\n * Creates a writable copy of the immutable document root object `root`.\n */\n\n\nfunction cloneRootObject(root) {\n  if (root[OBJECT_ID] !== '_root') {\n    throw new RangeError(`Not the root object: ${root[OBJECT_ID]}`);\n  }\n\n  return cloneMapObject(root, '_root');\n}\n\nmodule.exports = {\n  interpretPatch,\n  cloneRootObject\n};","map":null,"metadata":{},"sourceType":"script"}