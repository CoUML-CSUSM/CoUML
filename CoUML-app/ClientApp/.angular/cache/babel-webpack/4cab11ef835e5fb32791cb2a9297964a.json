{"ast":null,"code":"const {\n  OBJECT_ID\n} = require('./constants');\n\nconst {\n  isObject\n} = require('../src/common');\n\nclass Text {\n  constructor(text) {\n    if (typeof text === 'string') {\n      const elems = [...text].map(value => ({\n        value\n      }));\n      return instantiateText(undefined, elems); // eslint-disable-line\n    } else if (Array.isArray(text)) {\n      const elems = text.map(value => ({\n        value\n      }));\n      return instantiateText(undefined, elems); // eslint-disable-line\n    } else if (text === undefined) {\n      return instantiateText(undefined, []); // eslint-disable-line\n    } else {\n      throw new TypeError(`Unsupported initial value for Text: ${text}`);\n    }\n  }\n\n  get length() {\n    return this.elems.length;\n  }\n\n  get(index) {\n    const value = this.elems[index].value;\n\n    if (this.context && isObject(value)) {\n      const objectId = value[OBJECT_ID];\n      const path = this.path.concat([{\n        key: index,\n        objectId\n      }]);\n      return this.context.instantiateObject(path, objectId);\n    } else {\n      return value;\n    }\n  }\n\n  getElemId(index) {\n    return this.elems[index].elemId;\n  }\n  /**\n   * Iterates over the text elements character by character, including any\n   * inline objects.\n   */\n\n\n  [Symbol.iterator]() {\n    let elems = this.elems,\n        index = -1;\n    return {\n      next() {\n        index += 1;\n\n        if (index < elems.length) {\n          return {\n            done: false,\n            value: elems[index].value\n          };\n        } else {\n          return {\n            done: true\n          };\n        }\n      }\n\n    };\n  }\n  /**\n   * Returns the content of the Text object as a simple string, ignoring any\n   * non-character elements.\n   */\n\n\n  toString() {\n    // Concatting to a string is faster than creating an array and then\n    // .join()ing for small (<100KB) arrays.\n    // https://jsperf.com/join-vs-loop-w-type-test\n    let str = '';\n\n    for (const elem of this.elems) {\n      if (typeof elem.value === 'string') str += elem.value;\n    }\n\n    return str;\n  }\n  /**\n   * Returns the content of the Text object as a sequence of strings,\n   * interleaved with non-character elements.\n   *\n   * For example, the value ['a', 'b', {x: 3}, 'c', 'd'] has spans:\n   * => ['ab', {x: 3}, 'cd']\n   */\n\n\n  toSpans() {\n    let spans = [];\n    let chars = '';\n\n    for (const elem of this.elems) {\n      if (typeof elem.value === 'string') {\n        chars += elem.value;\n      } else {\n        if (chars.length > 0) {\n          spans.push(chars);\n          chars = '';\n        }\n\n        spans.push(elem.value);\n      }\n    }\n\n    if (chars.length > 0) {\n      spans.push(chars);\n    }\n\n    return spans;\n  }\n  /**\n   * Returns the content of the Text object as a simple string, so that the\n   * JSON serialization of an Automerge document represents text nicely.\n   */\n\n\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * Returns a writeable instance of this object. This instance is returned when\n   * the text object is accessed within a change callback. `context` is the\n   * proxy context that keeps track of the mutations.\n   */\n\n\n  getWriteable(context, path) {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('getWriteable() requires the objectId to be set');\n    }\n\n    const instance = instantiateText(this[OBJECT_ID], this.elems);\n    instance.context = context;\n    instance.path = path;\n    return instance;\n  }\n  /**\n   * Updates the list item at position `index` to a new value `value`.\n   */\n\n\n  set(index, value) {\n    if (this.context) {\n      this.context.setListIndex(this.path, index, value);\n    } else if (!this[OBJECT_ID]) {\n      this.elems[index].value = value;\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block');\n    }\n\n    return this;\n  }\n  /**\n   * Inserts new list items `values` starting at position `index`.\n   */\n\n\n  insertAt(index, ...values) {\n    if (this.context) {\n      this.context.splice(this.path, index, 0, values);\n    } else if (!this[OBJECT_ID]) {\n      this.elems.splice(index, 0, ...values.map(value => ({\n        value\n      })));\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block');\n    }\n\n    return this;\n  }\n  /**\n   * Deletes `numDelete` list items starting at position `index`.\n   * if `numDelete` is not given, one item is deleted.\n   */\n\n\n  deleteAt(index, numDelete = 1) {\n    if (this.context) {\n      this.context.splice(this.path, index, numDelete, []);\n    } else if (!this[OBJECT_ID]) {\n      this.elems.splice(index, numDelete);\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block');\n    }\n\n    return this;\n  }\n\n} // Read-only methods that can delegate to the JavaScript built-in array\n\n\nfor (let method of ['concat', 'every', 'filter', 'find', 'findIndex', 'forEach', 'includes', 'indexOf', 'join', 'lastIndexOf', 'map', 'reduce', 'reduceRight', 'slice', 'some', 'toLocaleString']) {\n  Text.prototype[method] = function (...args) {\n    const array = [...this];\n    return array[method](...args);\n  };\n}\n\nfunction instantiateText(objectId, elems) {\n  const instance = Object.create(Text.prototype);\n  instance[OBJECT_ID] = objectId;\n  instance.elems = elems;\n  return instance;\n}\n\nmodule.exports = {\n  Text,\n  instantiateText\n};","map":null,"metadata":{},"sourceType":"script"}